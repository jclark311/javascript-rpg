// RPG Architecture
// Japanese-style RPGs break down into separate systems very cleanly.
// Dinodeck takes care of the low-level actions,
// which means we don’t have to worry about low-level systems like interfacing
// with the graphics or sound card, loading files from disk, rendering text and so on.
// The systems we’ll be build, roughly in order, are:
// • Maps - loading and rendering
// • Movement system and animations, collision detection
// • Entities such as the player - animations and definition
// • User Interface - menus, etc.
// • Trigger system so players can interact with maps and other entities
// • Cutscenes
// • World State tracking - for quests, opened chests, stats, spells, item database,
// etc.
// • Inventory System
// • Saving and Loading
// • Combat System

// =============================================================================
// What is the highest possible damage you can do with a level 20 character
// (D&D 5e, optimization, damage, RPG)?
// =============================================================================
//
// Over 800k.
//
// This answer proceeds under the assumption that everything is RAW
// and there is no loopholes in the rules being exploited.
//
// Meteor swarm has a radius of 40 feet for each fireball.
// In addition each fireball does an average of around 120 damage.
//
//
// With 4 meteors you are covering a total area of 80,424.76 cubic feet.
// A tiny creature occupies 2.5 by 2.5 feet for a total of 15.625 cubic feet.
// A DM can fit 5147 tiny creatures into that one spell.
// A demilich is a tiny creature with 80 hp.
// If all space is occupied the meteor swarm will deal 433,360 damage.
// If you have a simalcrum who is also casting the spell you can cast it twice for 866,720 damage.
//
// Of course, no sane dm would ever put you in a situation where you are allowed to do this.
//
// If you know a tiny creature with more hp please tell me and I will update the answer.
//
// edit: I just realized demiliches are immune to magic.
// If you use a flameskull instead then it will deal a total of 433,360
// if all fail saving throws and you use a simalcrum.
//
// Alternatively if your DM allows, you could have 1030 casters use wish
// to get rid of the immunity to magical effects for 8 hours.
// If wish can grant immunity for 8 hours it should be allowed to
// grant immunity for 8 hours.
// But the chances of finding 1030 level 17+ full magic users is rare
// in any campaign(and just imagine the cost of hiring all them).
// --

// =============================================================================
// What is better for an RPG stat in JavaScript, an array or primitives?
// =============================================================================
//
// Do you mean how to organize the statistics (like HP, MP, armor, etc.)
// of entities in an RPG game? If so, I’d use objects and methods, not arrays or primitives..
// so you have an entity object, that has properties for all the statistics,
// and methods for all the actions (like attack, equip and similar).
// So later you can do something like playerObj.attack(enemyObj) and everything
// gets calculated automatically (or e.g. playerObj.equip(swordObj) and the attack
// stat changes automatically)
// --

var light;

var hero;

var character;
var warrior;
var mage;
var healer;
var paladin;
var thief;
var knight;
var ninja;
var rogue;

var player = {};
var enemies = [];

// var background;
var progress;
var bar;
var menuArrow;

// Menus
var partyActionsMenu;
var playerMenu;
var enemyMenu;

var playerMenuText;
var playerMenuArray = [];
var enemyMenuText;
var enemyMenuArray = [];
var actionsMenuText = {};
var actionMenuChildren = [];

var heroMenuStats;

// ENEMIES
var acid;
var andromalius;
var disciple;
var flameball;
var gnu;
var darkMage;
var minion;
var shadow;
var tentacles;

var mageBullet;
var tree;
var actionDefnsCommon;
var eventQueue;
var comet;

var combatScene;
var gPanel;
var left;
var top;
var right;
var bottom;

var particle_no;
var counter;
var particles;
var w;
var h;

var spritesheet;
var sprite;
var right_boundary;
var left_boundary;
var vx;
var stats;
var statsDef;
var heroDef;
var thiefDef;
var mageDef;

var textbox;
var world;
var growth;

var camera;

var textureAtlas;
var tileAtlasImage;

var gMap;
var gMapWidth;
var gMapHeight;
var mapDef;
var smallRoomMap;
var smallRoomDef;

var topLeftTile;
var bottomRightTile;

var gHero;
var gUpDoorTeleport;
var gDownDoorTeleport;

var gTriggerTop;
var gTriggerBot;
var egg;
var milk;
var sugar;
var rice;

var ricePudding;

var clickHandler;

var click;

var spy;
var playerHandler;

function startGame() {
  // world = World.create();

  textureAtlas = new Image();
  textureAtlas.src = "images/atlas.png";

  tileAtlasImage = new Image();
  tileAtlasImage.src = "images/rpg_indoor.png";

  mapDef = {
    tileAtlas: tileAtlasImage,
    tileSize: 16,
    tileOutputSize: 1.5,
    tilesets: {
      name: "collision_graphic",
      firstgid: 133,
      image: "images/collision_graphic.png",
    },
    layers: [[
      1, 2, 3, 4, 5, 6, 7, 8, 9, 2, 3, 4, 5, 6, 7, 8, 9, 2, 3, 4, 5, 6, 7, 8, 9, 2, 3, 4, 5, 6, 7, 8, 9, 2, 3, 4, 5, 6, 7, 8, 9, 2, 3, 4, 5, 6, 7, 8, 9, 2, 5, 6, 7, 8, 9, 10, 11,
      12, 13, 14, 15, 16, 17, 18, 19, 20, 13, 14, 15, 16, 17, 18, 19, 20, 13, 14, 15, 16, 17, 18, 19, 20, 13, 14, 15, 16, 17, 18, 19, 20, 13, 14, 15, 16, 17, 18, 19, 20, 13, 14, 15, 16, 17, 18, 19, 20, 13, 16, 17, 18, 19, 20, 21, 22,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      45, 46, 47, 48, 49, 50, 51, 52, 53, 46, 47, 48, 49, 50, 51, 52, 53, 46, 47, 48, 49, 50, 51, 52, 53, 46, 47, 48, 49, 50, 51, 52, 53, 46, 47, 48, 49, 50, 51, 52, 53, 46, 47, 48, 49, 50, 51, 52, 53, 46, 49, 50, 51, 52, 53, 54, 55,
      56, 57, 58, 59, 60, 61, 62, 63, 64, 57, 58, 59, 60, 61, 62, 63, 64, 57, 58, 59, 60, 61, 62, 63, 64, 57, 58, 59, 60, 61, 62, 63, 64, 57, 58, 59, 60, 61, 62, 63, 64, 57, 58, 59, 60, 61, 62, 63, 64, 57, 60, 61, 62, 63, 64, 65, 66,
    ], [
      0, 0, 0, 0, 31, 0, 0, 0, 0, 0, 30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 115, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 126, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67, 68, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 78, 79, 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ]],
    collision: [
      133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133,
      133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133,
      133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133,
      133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133,
    ]
  };

  smallRoomDef = {
    tileAtlas: tileAtlasImage,
    tileSize: 16,
    tileOutputSize: 1.5,
    layers: [[
      1, 2, 3, 4, 5, 6, 7, 8, 9, 2, 3, 4, 5, 6, 7, 8, 9, 2, 3, 4, 5, 6, 7, 8, 9, 2, 3, 4, 5, 6, 7, 8, 9, 2, 3, 4, 5, 6, 7, 8, 9, 2, 3, 4, 5, 6, 7, 8, 9, 2, 5, 6, 7, 8, 9, 10, 11,
      12, 13, 14, 15, 16, 17, 18, 19, 20, 13, 14, 15, 16, 17, 18, 19, 20, 13, 14, 15, 16, 17, 18, 19, 20, 13, 14, 15, 16, 17, 18, 19, 20, 13, 14, 15, 16, 17, 18, 19, 20, 13, 14, 15, 16, 17, 18, 19, 20, 13, 16, 17, 18, 19, 20, 21, 22,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      94, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 73, 72, 70,
      45, 46, 47, 48, 49, 50, 51, 52, 53, 46, 47, 48, 49, 50, 51, 52, 53, 46, 47, 48, 49, 50, 51, 52, 53, 46, 47, 48, 49, 50, 51, 52, 53, 46, 47, 48, 49, 50, 51, 52, 53, 46, 47, 48, 49, 50, 51, 52, 53, 46, 49, 50, 51, 52, 53, 54, 55,
      56, 57, 58, 59, 60, 61, 62, 63, 64, 57, 58, 59, 60, 61, 62, 63, 64, 57, 58, 59, 60, 61, 62, 63, 64, 57, 58, 59, 60, 61, 62, 63, 64, 57, 58, 59, 60, 61, 62, 63, 64, 57, 58, 59, 60, 61, 62, 63, 64, 57, 60, 61, 62, 63, 64, 65, 66,
    ], [
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67, 68, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 78, 79, 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ]],
  };

  gMap = new Map(mapDef);
  smallRoomMap = new Map(smallRoomDef);


	clickHandler = function (item) {
		console.log("fired: " + item);
	};

	click = new Click();

	click.subscribe(clickHandler);
	click.fire('event #1');
	click.unsubscribe(clickHandler);
	click.fire('event #2');
	click.subscribe(clickHandler);
	click.fire('event #3');

	// spy = new Spy();
	// playerHandler = new Player();

	// spy.subscribe(playerHandler);
	// spy.setPainKillers(10);
	// playerHandler.onKingPainKillerChange(10)

	egg = new SimpleIngredient("Egg", 155, 6, 0);
	milk = new SimpleIngredient("Milk", 42, 0, 0);
	sugar = new SimpleIngredient("Sugar", 387, 0,0);
	rice = new SimpleIngredient("Rice", 370, 8, 0);

	ricePudding = new CompoundIngredient("Rice Pudding");
	ricePudding.addIngredient(egg);
	ricePudding.addIngredient(rice);
	ricePudding.addIngredient(milk);
	ricePudding.addIngredient(sugar);

	console.log("A serving of rice pudding contains:");
	console.log(ricePudding.getCalories() + " calories");

  // camera = new Camera(gMap, 1024, 640);

  // gMap.triggers = [
  //     // -- Layer 1
  //   {
  // 		[gMap.coordToIndex(10, 12)]: gTriggerBot,
  // 		[gMap.coordToIndex(11, 2)]: gTriggerTop,
  //   }
  // ]

  statsDef = {
    hp_now: 300,
    hp_max: 300,
    mp_now: 300,
    mp_max: 300,
    strength: 10,
    speed: 10,
    intelligence: 10,
  };

  growth = {
    fast: new Dice().rollDice(3, 2),
    med: new Dice().rollDice(1, 3),
    slow: new Dice().rollDice(1, 2),
  };

  heroDef = {
    name: "Heroinicles",
    id: 1,
    actions: {},
    portrait: "images/combat_hero.png",
    stats: statsDef,
    statGrowth: {
      hp_max: new Dice().rollDice(4, 50) + 100,
      mp_max: new Dice().rollDice(2, 50) + 100,
      strength: growth.fast,
      speed: growth.fast,
      intelligence: growth.med,
    },
    xp: 0,
    level: 1,
  };

  // heroDef = {
  //   texture: "images/walk_cycle.png",
  //   width: 16,
  //   height: 24,
  //   startFrame: 9,
  //   tileX: 11,
  //   tileY: 3,
  //   layer: 1
  // }
  //
  // gHero = {
  //   animUp: [1, 2, 3, 4],
  //   animRight: [5, 6, 7, 8],
  //   animDown: [9, 10, 11, 12],
  //   animLeft: [13, 14, 15, 16],
  //   entity: Entity.Create(heroDef),
  //   Init: function(self) {
  //     self.controller = StateMachine.Create({
  //       wait: function() {return self.waitState},
  //       move: function() {return self.moveState},
  //     });
  //     self.waitState = WaitState.Create(self, gMap)
  //     self.moveState = MoveState.Create(self, gMap)
  //     self.controller.change("wait");
  //   }
  // }
  // gHero.Init()
  //
  // gUpDoorTeleport = Actions.Teleport(gMap, 11, 3)
  // gDownDoorTeleport = Actions.Teleport(gMap, 10, 11)
  // gUpDoorTeleport(null, gHero.entity)
  //
  //
  // gTriggerTop = Trigger.Create({OnEnter: gDownDoorTeleport})
  //
  // gTriggerBot = Trigger.Create({OnEnter: gUpDoorTeleport})

  thiefDef = {
    name: "Thursday",
    id: 2,
    actions: null,
    portrait: "images/combat_thief.png",
    stats: statsDef,
    statGrowth: {
      hp_max: new Dice().rollDice(4, 40) + 100,
      mp_max: new Dice().rollDice(2, 25) + 100,
      strength: growth.fast,
      speed: growth.fast,
      intelligence: growth.slow,
    },
    xp: 0,
    level: 1,
  };

  mageDef = {
    name: "Magii",
    id: 3,
    actions: null,
    portrait: "images/combat_mage.png",
    stats: statsDef, // -- starting stats
    statGrowth: {
      hp_max: new Dice().rollDice(3, 40) + 100,
      mp_max: new Dice().rollDice(4, 50) + 100,
      strength: growth.med,
      speed: growth.med,
      intelligence: growth.fast,
    },
    xp: 0,
    level: 1,

    // -- additional Actor definition info
  };

  // mage = Actor.create(mageDef)
  // thief = Actor.create(thiefDef)
  hero = new Actor();
  hero.create(heroDef);

  // HERO's PARTY
  character = new Character(
    "Erlkonig", // name
    null, // defnName
    null, // itemsEquipped
    null, // itemsInInventory
    "images/walk_cycle.png",
    new Coords(192, 0),
    16,
    24,
    new Coords(800, 260),
    4,
    12,
    15
  );
  ninja = new Character(
    "Ninja", // name
    null, // defnName
    null, // itemsEquipped
    null, // itemsInInventory
    "images/walk_cycle.png",
    new Coords(192, 48),
    16,
    24,
    new Coords(800, 300),
    4,
    12,
    15
  );
  // thief = new Character(
  // 	"Thief", // name
  // 	null, // defnName
  // 	null, // itemsEquipped
  // 	null, // itemsInInventory
  //   "images/combat_thief.png",
  //   new Coords(192, 24),
  //   16,
  //   24,
  //   new Coords(800, 340),
  //   4,
  //   12,
  //   15
  // );

  var thiefSpritesheet = new Image();
  thiefSpritesheet.src = "images/combat_thief.png";
  thief = new Sprite(thiefSpritesheet, 5, 13);
  thief.x = 800;
  thief.y = 120;

  rogue = new Character(
    "Rogue", // name
    null, // defnName
    null, // itemsEquipped
    null, // itemsInInventory
    "images/walk_cycle.png",
    new Coords(192, 72),
    16,
    24,
    new Coords(800, 380),
    4,
    12,
    15
  );
  paladin = new Character(
    "Paladin", // name
    null, // defnName
    null, // itemsEquipped
    null, // itemsInInventory
    "images/walk_cycle.png",
    new Coords(192, 96),
    16,
    24,
    new Coords(800, 420),
    4,
    12,
    15
  );
  knight = new Character(
    "Knight", // name
    null, // defnName
    null, // itemsEquipped
    null, // itemsInInventory
    "images/walk_cycle.png",
    new Coords(192, 120),
    16,
    24,
    new Coords(800, 460),
    4,
    12,
    15
  );
  healer = new Character(
    "Healer", // name
    null, // defnName
    null, // itemsEquipped
    null, // itemsInInventory
    "images/walk_cycle.png",
    new Coords(192, 144),
    16,
    24,
    new Coords(800, 500),
    4,
    12,
    15
  );

  mage = new Character(
    "Mage", // name
    null, // defnName
    null, // itemsEquipped
    null, // itemsInInventory
    "images/combat_mage.png",
    new Coords(0, 384),
    64,
    64,
    new Coords(780, 340),
    0,
    12,
    15
  );
  warrior = new Character(
    "Warrior", // name
    null, // defnName
    null, // itemsEquipped
    null, // itemsInInventory
    "images/walk_cycle.png",
    new Coords(192, 192),
    16,
    24,
    new Coords(800, 400),
    4,
    12,
    15
  );

  // ENEMIES
  // acid = new AnimateAcidSprite(
  // 	"Acid",
  //   "images/spritesheets/acid2-14x67.png",
  //   new Coords(0, 96),
  //   14,
  //   67,
  //   new Coords(10, 20),
  //   5,
  //   12,
  //   15
  // );

  var acidSpritesheet = new Image();
  acidSpritesheet.src = "images/spritesheets/acid2-14x67.png";
  acid = new Sprite(acidSpritesheet, 8, 3);
  acid.x = 10;
  acid.y = 20;
  // acid.offsetX = 12;
  // acid.sampleEnd = 15;

  // andromalius = new EnemySprite(
  // 	"Andromalius",
  //   "images/spritesheets/andromalius-57x88.png",
  //   new Coords(0, 96),
  //   57,
  //   88,
  //   new Coords(10, 120)
  // );

  var andromaliusSpritesheet = new Image();
  andromaliusSpritesheet.src = "images/spritesheets/andromalius-57x88.png";
  andromalius = new Sprite(andromaliusSpritesheet, 8, 3);
  andromalius.x = 10;
  andromalius.y = 120;

  var discipleSpritesheet = new Image();
  discipleSpritesheet.src = "images/spritesheets/disciple-45x51.png";
  disciple = new Sprite(discipleSpritesheet, 4, 3); // params: image, columns, rows
  disciple.x = 10;
  disciple.y = 220;

  var gnuSpritesheet = new Image();
  gnuSpritesheet.src = "images/spritesheets/gnu-120x100.png";
  gnu = new Sprite(gnuSpritesheet, 5, 4); // params: image, columns, rows
  gnu.x = 10;
  gnu.y = 300;

  // darkMage = new AnimateAcidSprite(
  // 	"Dark Mage",
  //   "images/spritesheets/mage-1-85x94.png",
  //   new Coords(0, 0),
  //   84,
  //   100,
  //   new Coords(10, 400),
  // 	8,
  //   1,
  //   3
  // );

  var darkMageSpritesheet = new Image();
  darkMageSpritesheet.src = "images/spritesheets/mage-1-85x94.png";
  darkMage = new Sprite(darkMageSpritesheet, 4, 2); // params: image, columns, rows
  darkMage.x = 10;
  darkMage.y = 400;

  // minion = new EnemySprite(
  // 	"Minion",
  //   "images/spritesheets/minion-45x66.png",
  //   new Coords(0, 0),
  //   46,
  //   60,
  //   new Coords(200, 400)
  // );

  // shadow = new AnimateAcidSprite(
  // 	"Shadow",
  //   "images/spritesheets/shadow-80x70.png",
  //   new Coords(240, 286),
  //   80,
  //   70,
  //   new Coords(200, 300),
  // 	6,
  //   1,
  //   14
  // );

  var shadowSpritesheet = new Image();
  shadowSpritesheet.src = "images/spritesheets/shadow-80x70.png";
  shadow = new Sprite(shadowSpritesheet, 4, 5); // params: image, columns, rows
  shadow.x = 200;
  shadow.y = 300;
  // shadow.offsetX = 0;

  // tentacles = new AnimateAcidSprite(
  // 	"Tentacle",
  //   "images/spritesheets/tentacles-25x90.png",
  //   new Coords(0, 0),
  //   25,
  //   90,
  //   new Coords(100, 240),
  // 	4,
  //   4,
  //   20
  // );

  var tentaclesSpritesheet = new Image();
  tentaclesSpritesheet.src = "images/spritesheets/tentacles-25x90.png";
  tentacles = new Sprite(tentaclesSpritesheet, 8, 3); // params: image, columns, rows
  tentacles.x = 100;
  tentacles.y = 240;

  // MENUS
  partyActionsMenu = new Menu(
    "Actions",
    new Coords(0, 526),
    340,
    112,
    null,
    null,
    enemyMenuArray,
    1
  );
  playerMenu = new Menu(
    "Party Names", // text
    new Coords(345, 526), // pos
    680, // width
    112, // height
    null, // menuable
    null, // updateEncounter
    playerMenuArray,
    0 // indexOfChildSelected
  );

  enemyMenu = new Menu(
    "Enemy Party", // text
    new Coords(0, 526), // pos
    680, // width
    112, // height
    null, // menuable
    null, // updateEncounter
    enemyMenuArray,
    2 // indexOfChildSelected
  );

  menuArrow = new drawTriangle();
  progress = new ProgressBar();

  mageBullet = new MagicExplosion(
    "images/spritesheets/mage-bullet-13x13.png",
    new Coords(0, 0),
    13,
    13,
    new Coords(500, 300),
    4,
    1,
    5
  );
  eventQueue = new EventQueue();

  eventQueue.add({ name: "Msg: Welcome to the Arena" }, -1);
  eventQueue.add({ name: "Take Turn Goblin" }, 5);
  eventQueue.add({ name: "Take Turn Hero" }, 4);

  // eventQueue.print()

  // Enqueue Events in State
  // myGameArea.state.events.map(event => eventQueue.enqueue(event));

  // Add Enemy Party to Menu
  // andromalius.toMenu();
  // disciple.toMenu();
  // flameball.toMenu();
  // gnu.toMenu();
  // darkMage.toMenu();
  // minion.toMenu();
  // shadow.toMenu();
  // tentacles.toMenu();

  // Add Party Data to Menu
  character.toMenu();
  ninja.toMenu();
  knight.toMenu();
  warrior.toMenu();
  mage.toMenu();
  healer.toMenu();
  comet = new Comet();

  Bullet.prototype.context = myGameArea.eCtx;
  Bullet.prototype.canvasWidth = myGameArea.environmentCanvas.width;
  Bullet.prototype.canvasHeight = myGameArea.environmentCanvas.height;

  combatScene = new CombatScene(
    {
      name: "hero",
      speed: 3,
      attack: 2,
      HP: 5,
      isPlayer: function () {
        return true;
      },
      isKOed: function () {
        return 0;
      },
    },
    {
      name: "goblin",
      speed: 2,
      attack: 2,
      HP: 5,
      isPlayer: function () {
        return false;
      },
      isKOed: function () {
        return 0;
      },
    }
  );

  // gPanel = new Panel({
  // 	texture: imageRepository.panelTexture,
  // 	size: 3
  // });
  //
  // gPanel.create();
  //
  // textbox = new Textbox({
  // 	text: "Hi",
  // 	textScale: 2,
  // 	panelArgs: {
  // 		texture: imageRepository.panelTexture,
  // 		size: 3
  // 	},
  // 	size: 200,
  // 	textbounds: 30
  // });

  // left = -100;
  // top = 0;
  // right = 100;
  // bottom = -100;
  // gPanel.position(left, top, right, bottom);

  // bar = new Progress();
  // stats = new Stats();
  // var playerStats = {
  // 	health: 100,
  // 	healthMax: 100,
  // 	energy: 10,
  // 	energyMax: 10,
  // 	str: 10,
  // 	spd: 10,
  // 	int: 10
  // }
  //
  // stats.create(playerStats);
  //
  // // console.log(stats.getBase('int'));
  //
  // var magic_hat = {
  //   unique_id: 1,
  //   modifier: {
  //     id: 2,
  //     add: {
  //       str: 5
  //     },
  //   }
  // }
  //
  // var magic_sword = {
  //   unique_id: 2,
  //   modifier: {
  //     add: {
  //     	str: 5,
  //       spd: 5
  //     }
  //   }
  // }
  //
  // stats.addModifier(magic_sword.unique_id, magic_sword.modifier);
  //
  // // console.log(stats.getBase("str"));
  // // console.log(stats.get("str"));
  //
  // stats.addModifier(magic_hat.unique_id, magic_hat.modifier);
  //
  // // console.log(stats.getBase("str"));
  // // console.log(stats.get("str"));
  //
  // var spell_curse = {
  //   unique_id: "curse",
  //   modifier: {
  //     mult: {
  //       str: -0.5,
  //       spd: -0.5,
  //       int: -0.5,
  //     }
  //   }
  // }
  //
  // var spell_bravery = {
  //   unique_id: "bravery",
  //   modifier: {
  //     mult: {
  //       str: 0.1,
  //       spd: 0.1,
  //       int: 0.1
  //     }
  //   }
  // }
  //
  // stats.addModifier(spell_bravery.unique_id, spell_bravery.modifier);
  //
  // // console.log(">Bravery +10% to all stats");
  // // console.log("str: ", stats.getBase("str"), stats.get("str"));
  // //
  // // console.log(">Cursed! All stats halved.");
  // stats.addModifier(spell_curse.unique_id, spell_curse.modifier);

  // console.log("str: ", stats.getBase("str"), stats.get("str"));

  // START
  // myGameArea.start();
}

var myGameArea = {
  terrainCanvas: document.getElementById("terrain"),
  playerCanvas: document.getElementById("player"),
  environmentCanvas: document.getElementById("environment"),
  hudCanvas: document.getElementById("hud"),

  state: {
    initial: "booting",
    events: [
      { name: "ready", from: "booting", to: "menu" }, // initial page loads images and sounds then transitions to 'menu'
      { name: "start", from: "menu", to: "starting" }, // start a new game from the menu
      { name: "load", from: ["starting", "playing"], to: "loading" }, // start loading a new level (either to start a new game, or next level while playing)
      { name: "play", from: "loading", to: "playing" }, // play the level after loading it
      { name: "help", from: ["loading", "playing"], to: "help" }, // pause the game to show a help topic
      { name: "resume", from: "help", to: "playing" }, // resume playing after showing a help topic
      { name: "lose", from: "playing", to: "lost" }, // player died
      { name: "quit", from: "playing", to: "lost" }, // player quit
      { name: "win", from: "playing", to: "won" }, // player won
      { name: "finish", from: ["won", "lost"], to: "menu" }, // back to menu
    ],
  },

  start: function () {
    this.tCtx = this.terrainCanvas.getContext("2d");
    this.pCtx = this.playerCanvas.getContext("2d");
    this.eCtx = this.environmentCanvas.getContext("2d");
    this.hCtx = this.hudCanvas.getContext("2d");

    this.frameNo = 0;
    this.interval = setInterval(updateGameArea, 20);
    window.addEventListener("keydown", function (e) {
      myGameArea.keys = myGameArea.keys || [];
      myGameArea.keys[e.keyCode] = e.type == "keydown";
    });
    window.addEventListener("keyup", function (e) {
      myGameArea.keys[e.keyCode] = e.type == "keydown";
    });
  },

  clear: function () {
    this.tCtx.clearRect(
      0,
      0,
      this.terrainCanvas.width,
      this.terrainCanvas.height
    );
    this.pCtx.clearRect(
      0,
      0,
      this.playerCanvas.width,
      this.playerCanvas.height
    );
    this.eCtx.clearRect(
      0,
      0,
      this.environmentCanvas.width,
      this.environmentCanvas.height
    );
    this.hCtx.clearRect(0, 0, this.hudCanvas.width, this.hudCanvas.height);
  },

  stop: function () {
    clearInterval(this.interval);
  },
};

// =================
// WORLD
// =================
var World = {};

World.create = function () {
  this.party = Party.create();
};

// Composite Pattern
function SimpleIngredient(name, calories, ironContent, vitaminCContent) {
  this.name = name;
  this.calories = calories;
  this.ironContent = ironContent;
  this.vitaminCContent = vitaminCContent;
}

SimpleIngredient.prototype.getName = function () {
  return this.name;
};

SimpleIngredient.prototype.getCalories = function () {
  return this.calories;
};

SimpleIngredient.prototype.getIronContent = function () {
  return this.ironContent;
};

SimpleIngredient.prototype.getVitaminCContent = function () {
  return this.vitaminCContent;
};

// It can be used interchangeably with a compound ingredient which has a list of ingredients:
function CompoundIngredient(name) {
  this.name = name;
  this.ingredients = [];
}

CompoundIngredient.prototype.addIngredient = function (ingredient) {
  this.ingredients.push(ingredient);
};

CompoundIngredient.prototype.getName = function () {
  return this.name;
};

CompoundIngredient.prototype.getCalories = function () {
  let total = 0;
  for (let i = 0; i < this.ingredients.length; i++) {
    total += this.ingredients[i].getCalories();
  }
  return total;
};

CompoundIngredient.prototype.getIronContent = function () {
  let total = 0;
  for (let i = 0; i < this.ingredients.length; i++) {
    total += this.ingredients[i].getIronContent();
  }

  return total;
};

CompoundIngredient.prototype.getVitaminCContent = function () {
  let total = 0;
  for (let i = 0; i < this.ingredients.length; i++) {
    total += this.ingredients[i].getVitaminCContent();
  }
  return total;
};

// Composite Pattern
var Node = function (name) {
    this.children = [];
    this.name = name;
}

Node.prototype = {
    add: function (child) {
        this.children.push(child);
    },

    remove: function (child) {
        var length = this.children.length;
        for (var i = 0; i < length; i++) {
            if (this.children[i] === child) {
                this.children.splice(i, 1);
                return;
            }
        }
    },

    getChild: function (i) {
        return this.children[i];
    },

    hasChildren: function () {
        return this.children.length > 0;
    }
}

// recursively traverse a (sub)tree
function traverse(indent, node) {
    console.log(Array(indent++).join("--") + node.name);

    for (var i = 0, len = node.children.length; i < len; i++) {
        traverse(indent, node.getChild(i));
    }
}

function runNodeComposite() {
    var tree = new Node("root");
    var left = new Node("left")
    var right = new Node("right");
    var leftleft = new Node("leftleft");
    var leftright = new Node("leftright");
    var rightleft = new Node("rightleft");
    var rightright = new Node("rightright");

    tree.add(left);
    tree.add(right);
    tree.remove(right);  // note: remove
    tree.add(right);

    left.add(leftleft);
    left.add(leftright);

    right.add(rightleft);
    right.add(rightright);

    traverse(1, tree);
}


// Composite Pattern
function File(name) {
  this.name = name;
}

File.prototype.display = function () {
  console.log(this.name);
};

function Directory(name) {
  this.name = name;
  this.files = [];
}

Directory.prototype.add = function (file) {
  this.files.push(file);
};

Directory.prototype.remove = function (file) {
  for (let i = 0, length = this.files.length; i < length; i++) {
    if (this.files[i] === file) {
      this.files.splice(i, 1);
      return true;
    }
  }

  return false;
};

Directory.prototype.getFileName = function (index) {
  return this.files[index].name;
};

Directory.prototype.display = function () {
  console.log(this.name);
  for (let i = 0, length = this.files.length; i < length; i++) {
    console.log("   ", this.getFileName(i));
  }
};

directoryOne = new Directory("Directory One");
directoryTwo = new Directory("Directory Two");
directoryThree = new Directory("Directory Three");

fileOne = new File("File One");
fileTwo = new File("File Two");
fileThree = new File("File Three");

directoryOne.add(fileOne);
directoryOne.add(fileTwo);

directoryTwo.add(fileOne);

directoryThree.add(fileOne);
directoryThree.add(fileTwo);
directoryThree.add(fileThree);

directoryOne.display();
directoryTwo.display();
directoryThree.display();

/*
Directory One
    File One
    File Two
Directory Two
    File One
Directory Three
    File One
    File Two
    File Three
*/

// Observer Pattern
function Spy() {
  this._partiesToNotify = [];
}

Spy.prototype.subscribe = function(subscriber) {
  this._partiesToNotify.push(subscriber);
}

Spy.prototype.unsubscribe = function(subscriber) {
  this._partiesToNotify.remove(subscriber);
}

Spy.prototype.setPainKillers = function(painKillers) {
  this._painKillers = painKillers;
  for (var i = 0; i < this._partiesToNotify.length; i++) {
    this._partiesToNotify[i](painKillers);
  }
}


function Player() {

}

Player.prototype.onKingPainKillerChange = function(newPainKillerAmount) {
	// perform some action
	console.log(newPainKillerAmount)
}

// Observer Pattern
function Click() {
    this.handlers = [];  // observers
}

Click.prototype = {

    subscribe: function (fn) {
        this.handlers.push(fn);
    },

    unsubscribe: function (fn) {
        this.handlers = this.handlers.filter(
            function (item) {
                if (item !== fn) {
                    return item;
                }
            }
        );
    },

    fire: function (o, thisObj) {
        var scope = thisObj || window;
        this.handlers.forEach(function (item) {
            item.call(scope, o);
        });
    }
}

// Observer Pattern
function Subject() {
	this.observers = [];
}

Subject.prototype.subscribeObserver = function(observer) {
	this.observers.push(observer);
};

Subject.prototype.unsubscribeObserver = function(observer) {
	var index = this.observers.indexOf(observer);
	if(index > -1) {
		this.observers.splice(index, 1);
	}
};

Subject.prototype.notifyObserver = function(observer) {
	var index = this.observers.indexOf(observer);
	if(index > -1) {
		this.observers[index].notify(index);
	}
};

Subject.prototype.notifyAllObservers = function() {
	for(var i = 0; i < this.observers.length; i++){
		this.observers[i].notify(i);
	};
};

var Observer = function() {
    return {
	    notify: function(index) {
	        console.log("Observer " + index + " is notified!");
	    }
    }
}

var subject = new Subject();

var observer1 = new Observer();
var observer2 = new Observer();
var observer3 = new Observer();
var observer4 = new Observer();

subject.subscribeObserver(observer1);
subject.subscribeObserver(observer2);
subject.subscribeObserver(observer3);
subject.subscribeObserver(observer4);

subject.notifyObserver(observer2); // Observer 2 is notified!

subject.notifyAllObservers();
// Observer 1 is notified!
// Observer 2 is notified!
// Observer 3 is notified!
// Observer 4 is notified!



// Store data as key-value pairs
function Dictionary() {
  this.datastore = {};
}

// insert a new key-value pair in the dictionary.
Dictionary.prototype.add = function (key, value) {
  this.datastore[key] = value;
};

Dictionary.prototype.find = function (key) {
  return this.datastore[key];
};

Dictionary.prototype.remove = function (key) {
  delete this.datastore[key];
};

Dictionary.prototype.showAll = function () {
  for (var key in this.datastore) {
    console.log(`${key} -> ${this.datastore[key]}`);
  }
};

Dictionary.prototype.count = function () {
  var n = 0;
  for (var key in this.datastore) {
    ++n;
  }
  return n;
};

Dictionary.prototype.clear = function () {
  for (var key in this.datastore) {
    delete this.datastore[key];
  }
};



// Iterator Pattern
var Iterator = function (items) {
    this.index = 0;
    this.items = items;
}

Iterator.prototype = {
    first: function () {
        this.reset();
        return this.next();
    },
    next: function () {
        return this.items[this.index++];
    },
    hasNext: function () {
        return this.index <= this.items.length;
    },
    reset: function () {
        this.index = 0;
    },
    each: function (callback) {
        for (var item = this.first(); this.hasNext(); item = this.next()) {
            callback(item);
        }
    }
}

function runIterator() {

    var items = ["one", 2, "circle", true, "Applepie"];
    var iter = new Iterator(items);

    // using for loop

    for (var item = iter.first(); iter.hasNext(); item = iter.next()) {
        console.log(item);
    }
    console.log("");

    // using Iterator's each method

    iter.each(function (item) {
        console.log(item);
    });
}

// Mediator Pattern
function Person(name) {
	this.name = name;
	this.chatLog = [];
}

Person.prototype.receive = function(sender, message) {
	let s = `${sender}: '${message}'`;
	console.log(`[${this.name}'s chat session'] ${s}`);
	this.chatLog.push(s);
}

Person.prototype.say = function(message) {
	this.room.broadcast(this.name, message);
}

Person.prototype.pm = function(who, message) {
	this.room.message(this.name, who, message);
}

function ChatRoom() {
	this.people = [];
}

ChatRoom.prototype.broadcast = function(source, message) {
	for (let p of this.people) {
		if (p.name !== source) {
			p.receive(source, message);
		}
	}
};

ChatRoom.prototype.join = function(p) {
	let joinMsg = `${p.name} joins the chat`;
	this.broadcast("room", joinMsg);
	p.room = this;
	this.people.push(p);
};

ChatRoom.prototype.message = function(source, destination, message) {
	for (let p of this.people) {
		if (p.name === destination) p.receive(source, message);
	}
};

var room = new ChatRoom();
var john = new Person("John");
var tony = new Person("Tony");

room.join(john);
room.join(tony);
john.say("Hello!!");

function stateChange(target, value) {
  console.log(`State of ${target} changed to ${value}`);
}

var state = {
  name: "",
  isLoaded: false,
  counter: 0,
  setState: function (target, value) {
    this[target] = value;
    stateChange(target, value);
  },
};

// =================
// ANIMATION
// =================
function Animation() {}

// =================
// ENTITY
// =================
function Entity() {}

function Teleport(entity, map) {
  var x;
  var y = map.getTileFoot(entity.tileX, entity.tileY);
  entity.sprite.setPosition(x, y + entity.height / 2);
}

var Trigger = {};

Trigger.Create = function (def) {
  EmptyFunc = function () {};

  // OnEnter is called when the player finishes arriving on a tile.
  OnEnter = def.OnEnter || EmptyFunc;

  // OnExit is called when a player finishes exiting a tile.
  OnExit = def.OnExit || EmptyFunc;

  // OnUse is called when the player presses the use button facing a tile.
  OnUse = def.OnUse || EmptyFunc;
};

// var gUpDoorTeleport = Actions.Teleport(gMap, 11, 3)
// var gDownDoorTeleport = Actions.Teleport(gMap, 10, 11)
// gUpDoorTeleport(null, gHero.entity) // replaces the old teleport call

var gTriggerTop = Trigger.Create({
  OnEnter: console.log("Entered Top"),
  // OnEnter: gDownDoorTeleport
});

var gTriggerBot = Trigger.Create({
  OnEnter: console.log("Entered Bottom"),
  // OnEnter: gUpDoorTeleport
});

function Camera(map, width, height) {
  this.x = 0;
  this.y = 0;
  this.width = width;
  this.height = height;
  this.maxX = map.cols * map.tileSize - width;
  this.maxY = map.rows * map.tileSize - height;
}

Camera.prototype.follow = function (sprite) {
  this.following = sprite;
  sprite.screenX = 0;
  sprite.screenY = 0;
};

Camera.prototype.update = function () {
  // assume followed sprite should be placed at the center of the screen
  // whenever possible
  this.following.screenX = this.width / 2;
  this.following.screenY = this.height / 2;

  // make the camera follow the sprite
  this.x = this.following.x - this.width / 2;
  this.y = this.following.y - this.height / 2;
  // clamp values
  this.x = Math.max(0, Math.min(this.x, this.maxX));
  this.y = Math.max(0, Math.min(this.y, this.maxY));

  // in map corners, the sprite cannot be placed in the center of the screen
  // and we have to change its screen coordinates

  // left and right sides
  if (
    this.following.x < this.width / 2 ||
    this.following.x > this.maxX + this.width / 2
  ) {
    this.following.screenX = this.following.x - this.x;
  }
  // top and bottom sides
  if (
    this.following.y < this.height / 2 ||
    this.following.y > this.maxY + this.height / 2
  ) {
    this.following.screenY = this.following.y - this.y;
  }
};

// =================
// MAP
// =================

// The Map constructor takes a single parameter, mapDef
// The mapDef parameter is a Tiled map definition.
// get the texture, create a tile sprite, and generate UVs for the texture map
function Map(mapDef) {
  this.tileAtlas = mapDef.tileAtlas;
  this.layers = mapDef.layers;
  this.tileSize = mapDef.tileSize;
  // this.tiles = mapDef.tiles;
  this.tileOutputSize = mapDef.tileOutputSize;
  this.updatedTileSize = this.tileSize * this.tileOutputSize;

	// determine the number of rows and columns
	// to iterate over full width & height of canvas
	this.cols = myGameArea.terrainCanvas.width / this.tileSize;
  this.rows = myGameArea.terrainCanvas.height / this.tileSize;

  // determine the size of a single image cell
  this.width = mapDef.tileAtlas.width / this.cols;
  this.height = mapDef.tileAtlas.height / this.rows;

  this.blockingTile = mapDef.tilesets;
}

Map.prototype.getTile = function (layer, col, row) {
  // var x = x + 1; // -- change from  1 -> rowsize
  // -- to           0 -> rowsize - 1
  return this.layers[layer][row * this.cols + col];
};

Map.prototype.isSolidTileAtXY = function (x, y) {
  var col = Math.floor(x / this.tileSize);
  var row = Math.floor(y / this.tileSize);

  // tiles 3 and 5 are solid -- the rest are walkable
  // loop through all layers and return TRUE if any tile is solid
  return this.layers.reduce(
    function (res, layer, index) {
      var tile = this.getTile(index, col, row);
      var isSolid = tile === 133;
      return res || isSolid;
    }.bind(this),
    false
  );
};

Map.prototype.isBlocked = function (layer, tileX, tileY) {
  var tile = this.getTile(tileX, tileY, layer + 1);
  return tile === this.blockingTile.firstgid;
}

Map.prototype.drawLayer = function (layer) {
  	this.gamearea = myGameArea;

  	ctx = this.gamearea.tCtx;

    let tileSize = 16;
    let tileOutputSize = 1.125; // 1X can set it higher to make tiles bigger and more spaced
    let updatedTileSize = tileSize * tileOutputSize;

    let atlasCol = 11;
    let atlasRow = 12;

    let mapRows = 40;
    let mapCols = 64;
    let mapHeight = mapRows * updatedTileSize;
    let mapWidth = mapCols * updatedTileSize;

    let mapIndex = 0;
    let sourceX = 0;
    let sourceY = 0;

    for (var c = 0; c < 600; c += tileSize) {
      for (var r = 0; r < 900; r += tileSize) {
        let tileVal = this.layers[layer][mapIndex];
        var tile = this.getTile(layer, c, r);
        if (tile !== 0) {
          // 0 => empty tile
          tileVal -= 1;
          sourceY = Math.floor(tileVal / atlasCol) * tileSize;
          sourceX = (tileVal % atlasCol) * tileSize;

          ctx.drawImage(
            this.tileAtlas,
            sourceX,
            sourceY,
            tileSize,
            tileSize,
            r * tileOutputSize,
            c * tileOutputSize,
            tileSize * tileOutputSize,
            tileSize * tileOutputSize
          );
        }
        mapIndex++;
  		}
  	}
};

Map.prototype.render = function () {
  // draw map background layer
  this.drawLayer(0);

  // draw map top layer
  this.drawLayer(1);

};

// =================
// MOVE STATE
// =================
function MoveState() {}

// =================
// STATE MACHINE
// =================
function StateMachine() {}

// =================
// TWEEN
// =================
function Tween() {}

// =================
// UTILS
// =================
function Utils() {}

// =================
// WAIT STATE
// =================
function WaitState() {}

// =================
// WALK STATE
// =================
function WalkState() {}

/**
 * QuadTree object.
 *
 * The quadrant indexes are numbered as below:
 *     |
 *  1  |  0
 * —-+—-
 *  2  |  3
 *     |
 */
function QuadTree(boundBox, lvl) {
  var maxObjects = 10;
  this.bounds = boundBox || {
    x: 0,
    y: 0,
    width: 0,
    height: 0,
  };
  var objects = [];
  this.nodes = [];
  var level = lvl || 0;
  var maxLevels = 5;

  /**
   * Clears the quadTree and all nodes of objects
   */
  this.clear = function () {
    objects = [];
    for (var i = 0; i < this.nodes.length; i++) {
      this.nodes[i].clear();
    }
    this.nodes = [];
  };
}

// Page 435
function Actor() {
  this.name = null;
  this.id = null;
  this.actions = null;
  this.portrait = null;
  // new Sprite(acidSpritesheet, 8, 3);
  // this.portrait = Sprite.create();
  this.stats = null;
  this.statGrowth = null;
  // this.stats = Stats.create(def.stats);
  this.xp = null;
  this.level = null;
  this.nextLevelXP = null;
}

Actor.prototype.create = function (def) {
  var growth = def.statGrowth || {};
  var img = new Image();
  img.src = def.portrait;

  this.name = def.name;
  this.id = def.id;
  this.actions = def.actions;
  this.portrait = img;
  // new Sprite(acidSpritesheet, 8, 3);
  // this.portrait = Sprite.create();
  this.stats = def.stats;
  // this.stats = Stats.create(def.stats);
  this.statGrowth = growth;
  this.xp = def.xp || 0;
  this.level = def.level || 1;
  // this.euipment = {
  //   weapon: def.weapon,
  //   armor: def.armor,
  //   acces1: def.acces1,
  //   acces2: def.acces2,
  // }
  //
  this.nextLevelXP = NextLevel(this.level);
};

Actor.prototype.readyToLevelUp = function () {
  return this.xp >= this.nextLevelXP;
};

Actor.prototype.addXP = function (xp) {
  this.xp = this.xp + xp;
  return this.readyToLevelUp();
};

Actor.prototype.createLevelUp = function () {
  this.levelup = {
    xp: this.nextLevelXP,
    level: 1,
    stats: {},
  };

  for (const [key, value] of Object.entries(this.statGrowth)) {
    console.log(`${key}: ${value}`);
    // console.log(this.levelup.stats[key])
    this.levelup.stats[key] = this.statGrowth[key];
    // Growth dice must return # of dice to roll and # of sides to be rolled
    // levelup.stats[id] = this.dice:Roll()
  }

  return this.levelup;
};

Actor.prototype.applyLevel = function () {
  this.xp = this.xp + this.levelup.xp;
  this.level = this.level + this.levelup.level;
  this.nextLevelXP = NextLevel(this.level);

  for (const [key, value] of Object.entries(this.levelup.stats)) {
    console.log(`${key} = ${this.stats[key] + value}`);
    this.stats[key] = this.stats[key] + value;
  }

  // -- Unlock any special abilities etc.
};

function Dice() {
  this.dice = {};
  this.sides = [];
  this.rolling = false;
}

Dice.prototype.randomIntegerFromRange = function (min, max) {
  return (
    Math.floor(Math.random() * (Math.floor(max) - Math.floor(min) + 1)) +
    Math.floor(min)
  );
};

Dice.prototype.randomInteger = function (max) {
  var _max = max || 100;
  return Math.floor(Math.random() * Math.floor(_max));
};

Dice.prototype.rollD20 = function () {
  return this.randomIntegerFromRange(1, 20);
};

Dice.prototype.rollDice = function (dice, sides) {
  let result = 0;
  for (let i = 1; i <= dice; i++) {
    result += this.randomIntegerFromRange(1, sides);
  }
  return result;
};

Dice.prototype.roll = function () {
  this.rolling = true;
  this.rollDice(this.dice, this.sides);
};

function NextLevel(level) {
  this.exponent = 1.5;
  this.baseXP = 1000;
  return Math.floor(this.baseXP * level ** this.exponent);
}

// =================
// COMBAT FLOW
// =================
// Our combat is turn-based.
// Each Actor is asked, in turn, what action they’d like to take.
// A combat action is an attack, spell, item or any similar action.
// Turn order is determined by the speed stat.

// =================
// An Event Queue
// =================
function EventQueue() {
  this.events = [];
  this.currentEvent = null;
}

// The Add function takes in an event and a number of time points.
// Time points are stored in the countDown field.
// The countdown number is used to insert the event at the correct
// position in the EventQueue.
EventQueue.prototype.add = function (event, timePoints) {
  var queue = this.events;

  // -- Instant event
  if (timePoints === -1) {
    event.countDown = -1;
    this.events.push(event);
    // table.insert(queue, 1, event);
  }

  event.countDown = timePoints;

  // -- loop through events
  for (var i = 0; queue.length > i; i++) {
    var count = queue[i].countDown;

    if (count > event.countDown) {
      this.events.push(event);
      // table.insert(queue, i, event)
      return;
    }
  }

  // table.insert(queue, event)
  this.events.push(event);
};

EventQueue.prototype.enqueue = function (e) {
  this.events.push(e);
};

// remove an element from the front of the queue
EventQueue.prototype.dequeue = function () {
  return this.events.shift();
};

// check if the queue is empty
EventQueue.prototype.isEmpty = function () {
  return this.events.length === 0;
};

// get the element at the front of the queue
EventQueue.prototype.peek = function () {
  return !this.isEmpty() ? this.events[0] : undefined;
};

EventQueue.prototype.length = function () {
  return this.events.length;
};

EventQueue.prototype.speedToTimePoints = function (speed) {
  var maxSpeed = 255;
  speed = Math.min(speed, 255);
  var points = maxSpeed - speed;
  return Math.floor(points);
};

// The Update function is used to pump the queue and run the events.
EventQueue.prototype.update = function () {
  if (this.currentEvent != null) {
    this.currentEvent.update();

    if (this.currentEvent.isFinished()) {
      this.currentEvent = null;
    } else {
      return;
    }
  } else if (this.isEmpty()) {
    return;
  } else {
    // -- Need to chose an event
    // var front = table.remove(this.events, 1);
    var front = this.peek();
    front.execute(this);
    this.currentEvent = front;
  }

  for (var i = 0; this.events.length > i; i++) {
    this.events[i].countDown = Math.max(0, this.events[i].countDown - 1);
  }
};

EventQueue.prototype.clear = function () {
  this.events = [];
  this.currentEvent = null;
};

EventQueue.prototype.actorHasEvent = function (actor) {
  var current = this.currentEvent || {};

  if (current.owner == actor) {
    return true;
  }

  for (var v in this.events) {
    if (v.owner == actor) {
      return true;
    }
  }

  return false;
};

EventQueue.prototype.removeEventsOwnedBy = function (actor) {
  for (var i = 0; this.events.length > i; i++) {
    var v = this.events[i];
    if (v.owner == actor) {
      this.dequeue(this.events[i]);
    }
  }
};

EventQueue.prototype.print = function () {
  var queue = this.events;

  if (this.isEmpty()) {
    // console.log("Event Queue is empty.");
    return;
  }

  // console.log("Event Queue:")

  var current = this.currentEvent || {};

  // console.log("Current Event: ", current.name);

  for (var i = 0; this.events.length > i; i++) {
    // var out = string.format("[%d] Event: [%d][%s]",
    //                             k, v.countDown, v.name)
    // console.log("Event: ", this.events[i].countDown, this.events[i].name);
  }
};

/**
 * Emit a custom event
 * @param  {String} type   The event type
 * @param  {Object} detail Any details to pass along with the event
 * @param  {Node}   elem   The element to attach the event to
 */
function emitEvent(type, detail = {}, elem = document) {
  // Make sure there's an event type
  if (!type) return;

  // Create a new event
  let event = new CustomEvent(type, {
    bubbles: true,
    cancelable: true,
    detail: detail,
  });

  // Dispatch the event
  return elem.dispatchEvent(event);
}

function CEAttack(scene, owner, target) {
  this.scene = scene;
  this.owner = owner;
  this.target = target;
  this.name = `CEAttack(${owner.name}, ${target.name})`;
}

CEAttack.prototype.timePoints = function (queue) {
  var speed = this.owner.speed;
  return queue.speedToTimePoints(speed);
};

CEAttack.prototype.execute = function (queue) {
  var target = this.target;

  // Already killed!
  if (target.HP <= 0) {
    // Get a new random target
    target = this.scene.getTarget(this.owner);
  }

  var damage = this.owner.attack;
  target.HP = target.HP - damage;

  var msg = `${target.name} hit for ${damage} damage`;
  console.log(msg);

  if (target.HP < 0) {
    msg = `${target.name} is killed.`;
    console.log(msg);

    this.scene.onDead(target);
  }
};

CEAttack.prototype.update = function () {
  // -- Once again this is instant
};

CEAttack.prototype.isFinished = function () {
  return true;
};

// Combat Event Turn
function CETurn(scene, owner) {
  this.scene = scene;
  this.owner = owner;
  this.name = `CETurn(${owner.name})`;
}

CETurn.prototype.timePoints = function (queue) {
  var speed = this.owner.speed;
  return queue.speedToTimePoints(speed);
};

CETurn.prototype.execute = function (queue) {
  // Choose a random enemy target.
  var target = this.scene.getTarget(this.owner);
  var msg = `${this.owner.name} decides to attack ${target.name}`;
  console.log(msg);

  var event = new CEAttack(this.scene, this.owner, target);
  var tp = event.timePoints(queue);
  queue.add(event, tp);
};

CETurn.prototype.update = function () {
  // -- Nothing
};

CETurn.prototype.isFinished = function () {
  return true;
};

function CombatScene(party, enemies) {
  this.partyActors = party || {};
  this.enemyActors = enemies || {};
  this.eventQueue = new EventQueue();
}

CombatScene.prototype.create = function () {
  this.addTurns(this.partyActors);
  this.addTurns(this.enemyActors);
};

CombatScene.prototype.update = function () {
  this.eventQueue.update();

  if (this.isPartyDefeated() || this.isEnemyDefeated()) {
    // End Game Detected
    this.eventQueue.events = [];
  }

  // Otherwise, keep the queue going.
  this.addTurns(this.partyActors);
  this.addTurns(this.enemyActors);
};

CombatScene.prototype.addTurns = function (actorList) {
  for (var i = 0; actorList.length > i; i++) {
    if (!this.eventQueue.actorHasEvent(actorList[i])) {
      var event = new CETurn(actorList[i]);
      var tp = event.timePoints(this.eventQueue);
      this.eventQueue.add(event, tp);
    }
  }
};

CombatScene.prototype.onDead = function (actor) {
  if (actor.isPlayer()) {
    actor.KO();
  }

  for (var i = 0; i < this.enemyActors.length; i++) {
    var enemy = this.enemyActors[i];
    if (actor === enemy) {
      table.remove(this.enemyActors[i]);
    }
  }

  // -- Remove owned events
  this.eventQueue.removeEventsOwnedBy(actor);

  if (this.isPartyDefeated()) {
    console.log("Party loses");
  } else if (this.isEnemyDefeated()) {
    console.log("Party wins");
  }
};

CombatScene.prototype.getTarget = function (actor) {
  var targetList = null;

  if (actor.IsPlayer()) {
    targetList = this.enemyActors;
  } else {
    targetList = this.getLivePartyActors();
  }

  return targetList[targetList];
};

CombatScene.prototype.getLivePartyActors = function () {
  var live = {};

  for (var actor in this.partyActors) {
    if (!actor.isKOed()) {
      table.insert(live, actor);
    }
  }

  return live;
};

CombatScene.prototype.isPartyDefeated = function () {
  for (var actor in this.partyActors) {
    if (!actor.isKOed()) {
      return false;
    }
  }

  return true;
};
// Page 547; /examples_combat/event-queue-2-solution
CombatScene.prototype.isEnemyDefeated = function () {
  return this.enemyActors === 0;
};

var imageRepository = new (function () {
  // Define images
  this.background = new Image();
  this.spaceship = new Image();
  this.bullet = new Image();
  this.enemy = new Image();
  this.enemyBullet = new Image();
  this.panelTexture = new Image();
  // Ensure all images have loaded before starting the game
  var numImages = 6;
  var numLoaded = 0;
  function imageLoaded() {
    numLoaded++;
    if (numLoaded === numImages) {
      // START
      myGameArea.start();
    }
  }
  this.background.onload = function () {
    imageLoaded();
  };
  this.spaceship.onload = function () {
    imageLoaded();
  };
  this.bullet.onload = function () {
    imageLoaded();
  };
  this.enemy.onload = function () {
    imageLoaded();
  };
  this.enemyBullet.onload = function () {
    imageLoaded();
  };
  this.panelTexture.onload = function () {
    imageLoaded();
  };
  // Set images src
  this.background.src =
    "images/Battle-background-hazy-hills-files/PNG/battle-background-sunny-hillsX4.png";
  this.spaceship.src = "images/walk_cycle.png";
  this.bullet.src = "images/spritesheets/mage-bullet-13x13.png";
  this.enemy.src = "images/walk_cycle.png";
  this.enemyBullet.src = "images/spritesheets/mage-bullet-13x13.png";
  this.panelTexture.src = "images/simple_panel.png";
})();

/**
 * Creates the Drawable object which will be the base class for
 * all drawable objects in the game. Sets up defualt variables
 * that all child objects will inherit, as well as the defualt
 * functions.
 */
function Drawable() {
  this.init = function (x, y, width, height) {
    // Defualt variables
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  };

  this.speed = 0;
  this.canvasWidth = 0;
  this.canvasHeight = 0;

  // Define abstract function to be implemented in child objects
  this.draw = function () {};
  this.move = function () {};
}

/**
 * Creates the Bullet object which the ship fires. The bullets are
 * drawn on the "main" canvas.
 */
function Bullet(object) {
  this.alive = false; // Is true if the bullet is currently in use
  var self = object;

  this.gamearea = myGameArea;
  /*
   * Sets the bullet values
   */
  this.spawn = function (x, y, speed) {
    this.x = x;
    this.y = y;
    this.speed = speed;
    this.alive = true;
  };

  /*
   * Uses a "drity rectangle" to erase the bullet and moves it.
   * Returns true if the bullet moved of the screen, indicating that
   * the bullet is ready to be cleared by the pool, otherwise draws
   * the bullet.
   */
  this.draw = function () {
    myGameArea.eCtx.clearRect(
      this.x - 1,
      this.y - 1,
      this.width + 1,
      this.height + 1
    );
    this.x -= this.speed;
    if (self === "bullet" && this.x <= 0 - this.width) {
      return true;
    } else if (self === "enemyBullet" && this.x >= this.canvasWidth) {
      return true;
    } else {
      if (self === "bullet") {
        myGameArea.eCtx.drawImage(imageRepository.bullet, this.x, this.y);
      } else if (self === "enemyBullet") {
        myGameArea.eCtx.drawImage(imageRepository.enemyBullet, this.x, this.y);
      }

      return false;
    }
  };

  /*
   * Resets the bullet values
   */
  this.clear = function () {
    this.x = 0;
    this.y = 0;
    this.speed = 0;
    this.alive = false;
  };
}
Bullet.prototype = new Drawable();

/**
 * Custom Pool object. Holds Bullet objects to be managed to prevent
 * garbage collection.
 * The pool works as follows:
 * - When the pool is initialized, it popoulates an array with
 *   Bullet objects.
 * - When the pool needs to create a new object for use, it looks at
 *   the last item in the array and checks to see if it is currently
 *   in use or not. If it is in use, the pool is full. If it is
 *   not in use, the pool "spawns" the last item in the array and
 *   then pops it from the end and pushed it back onto the front of
 *   the array. This makes the pool have free objects on the back
 *   and used objects in the front.
 * - When the pool animates its objects, it checks to see if the
 *   object is in use (no need to draw unused objects) and if it is,
 *   draws it. If the draw() function returns true, the object is
 *   ready to be cleaned so it "clears" the object and uses the
 *   array function splice() to remove the item from the array and
 *   pushes it to the back.
 * Doing this makes creating/destroying objects in the pool
 * constant.
 */
function Pool(maxSize) {
  var size = maxSize; // Max bullets allowed in the pool
  var pool = [];

  /*
   * Populates the pool array with the given object
   */
  this.init = function (object) {
    if (object == "bullet") {
      for (var i = 0; i < size; i++) {
        // Initalize the object
        var bullet = new Bullet("bullet");
        bullet.init(
          0,
          0,
          imageRepository.bullet.width / 5,
          imageRepository.bullet.height
        );
        pool[i] = bullet;
      }
    } else if (object == "enemy") {
      for (var i = 0; i < size; i++) {
        var enemy = new Enemy();
        enemy.init(
          0,
          0,
          imageRepository.enemy.width,
          imageRepository.enemy.height
        );
        pool[i] = enemy;
      }
    } else if (object == "enemyBullet") {
      for (var i = 0; i < size; i++) {
        var bullet = new Bullet("enemyBullet");
        bullet.init(
          0,
          0,
          imageRepository.enemyBullet.width,
          imageRepository.enemyBullet.height
        );
        pool[i] = bullet;
      }
    }
  };

  /*
   * Grabs the last item in the list and initializes it and
   * pushes it to the front of the array.
   */
  this.get = function (x, y, speed) {
    if (!pool[size - 1].alive) {
      pool[size - 1].spawn(x, y, speed);
      pool.unshift(pool.pop());
    }
  };

  /*
   * Used for the ship to be able to get two bullets at once. If
   * only the get() function is used twice, the ship is able to
   * fire and only have 1 bullet spawn instead of 2.
   */
  this.getTwo = function (x1, y1, speed1, x2, y2, speed2) {
    if (!pool[size - 1].alive && !pool[size - 2].alive) {
      this.get(x1, y1, speed1);
      this.get(x2, y2, speed2);
    }
  };

  /*
   * Draws any in use Bullets. If a bullet goes off the screen,
   * clears it and pushes it to the front of the array.
   */
  this.animate = function () {
    for (var i = 0; i < size; i++) {
      // Only draw until we find a bullet that is not alive
      if (pool[i].alive) {
        if (pool[i].draw()) {
          pool[i].clear();
          pool.push(pool.splice(i, 1)[0]);
        }
      } else break;
    }
  };
}

function everyinterval(n) {
  if ((myGameArea.frameNo / n) % 1 == 0) {
    return true;
  }
  return false;
}

function Arrow() {
  this.x = 0;
  this.y = 0;
  this.color = "#ffff00";
  this.rotation = 0;
}

Arrow.prototype.draw = function (context) {
  context.save();
  context.translate(this.x, this.y);
  context.rotate(this.rotation);

  context.lineWidth = 2;
  context.fillStyle = this.color;
  context.beginPath();
  context.moveTo(-50, -25);
  context.lineTo(0, -25);
  context.lineTo(0, -50);
  context.lineTo(50, 0);
  context.lineTo(0, 50);
  context.lineTo(0, 25);
  context.lineTo(-50, 25);
  context.lineTo(-50, -25);
  context.closePath();
  context.fill();
  context.stroke();

  context.restore();
};

function Coords(x, y) {
  this.x = x;
  this.y = y;
}

function Stats() {
  this.base = {};
  this.modifiers = {};
}

Stats.prototype.create = function (stats) {
  // -- Shallow copy
  const keys = Object.keys(stats);

  keys.forEach((key) => {
    this.base[key] = stats[key];
  });
};

Stats.prototype.getBase = function (id) {
  return this.base[id];
};

Stats.prototype.set = function (id, value) {
  this.base[id] = value;
};

Stats.prototype.addModifier = function (id, modifier) {
  this.modifiers[id] = {
    add: modifier.add || {},
    mult: modifier.mult || {},
  };
};

Stats.prototype.removeModifier = function (id) {
  this.modifiers[id] = null;
};

Stats.prototype.get = function (id) {
  var total = this.base[id] || 0;
  var multiplier = 0;

  for (var i = 0; i < this.modifiers.length; i++) {
    for (var j = 0; j < this.modifiers.length; i++) {
      total = total + (this.modifiers[i].add[id] || 0);
      multiplier = multiplier + (this.modifiers[i].mult[id] || 0);
    }
  }
  // print(string.format("Multiplier: %f", multiplier))
  return total + total * multiplier;
};

/**
 * @constructor
 * @param {Image} spritesheet A sprite sheet is divided into cells and grouped into animation sequences.
 *                            This example assumes an even distribution and positioning within a rectangle.
 * @param {number} columns    Amount of sample images in the animation sequence.
 * @param {number} rows       Amount of different animation sequences on a single sprite sheet.
 */
function Sprite(spritesheet, columns, rows) {
  this.spritesheet = spritesheet;
  this.x = 0;
  this.y = 0;
  // determine the size of a single image cell
  this.width = spritesheet.width / columns;
  this.height = spritesheet.height / rows;

  this.rotation = 0;
  this.scaleX = 1;
  this.scaleY = 1;

  // position on the sprite sheet to start drawing from
  this.offsetX = 0;
  this.offsetY = 0;

  // these account for the player timeline of an animation sequence
  this.isPlaying = false;
  this.counter = 0; //	Updated every frame that a sequence is being played. From 0 to this.sampleEnd.
  this.sampleRate = 5; //	The amount of frames to play each sample cell before transitioning to the next. The higher the number, the slower the walk cycle.
  this.sampleChange = this.sampleRate; //	The next change point on the timeline that will cause a sample transition.
  this.sampleEnd = this.sampleRate * columns; //	The end of the timeline.

  this.isColliding = false;
}

/**
 * Select an animation sequence to play, as grouped by rows on the sprite sheet.
 * @param {number} direction  Animation sequence to play. Options: Sprite.RIGHT, Sprite.LEFT, Sprite.DOWN, and Sprite.UP
 */
Sprite.prototype.play = function (direction) {
  /* The sprite sheet is grouped by rows, and each row contains the cells for animating a particular direction.
   * When picking a direction to animate, determine the row's y-offset on the sprite sheet.
   * The class variables (eg. Sprite.UP) have no meaning by themselves, they're just used for convenience.
   */
  switch (direction) {
    case Sprite.RIGHT:
      this.offsetY = 0; //	row 1
      break;
    case Sprite.LEFT:
      this.offsetY = this.height; //	row 2
      break;
    case Sprite.DOWN:
      this.offsetY = this.height * 2; //	row 3
      break;
    case Sprite.UP:
      this.offsetY = this.height * 3; //	row 4
      break;
    default:
      throw new Error("Unknown Sprite direction.");
  }

  /* If this is the first play, position the player head right before the first change point.
   * Now there's an immediate animation transition instead of waiting through all the frames of the first sample.
   */
  if (!this.isPlaying) {
    this.counter = this.sampleRate - 1;
    this.isPlaying = true;
  }
};

/**
 * Stop playing the animation and reset the sample sequence.
 */
Sprite.prototype.stop = function () {
  this.isPlaying = false;
  this.resetCounter();
};

/**
 * Resets the counter and x-offset on the sprite sheet to point to the first sample of the animation sequence.
 */
Sprite.prototype.resetCounter = function () {
  this.counter = 0;
  this.offsetX = 0;
  this.sampleChange = this.sampleRate;
};

/**
 * Keeps track of the frame counter and timeline change points.
 * Each sample cell in an animation sequence is rendered a set amount of frames (as determined by this.sampleRate) before
 * moving on to the next sample. When the counter has reached the end of the sequence it is reset.
 */
Sprite.prototype.tick = function () {
  if (this.counter === this.sampleEnd) {
    this.resetCounter();
  } else if (this.counter === this.sampleChange) {
    // once a change point has been reached, update the x-offset on the sprite sheet to point to a new sample.
    this.offsetX += this.width;
    this.sampleChange += this.sampleRate; // set next change point
  }
  this.counter += 1;
};

Sprite.prototype.draw = function (context) {
  context.save();
  context.translate(this.x, this.y);
  context.rotate(this.rotation);
  context.scale(this.scaleX, this.scaleY);

  if (this.isPlaying === true) {
    this.tick();
  }
  /* Draws a slice from the source image to the canvas element destination.
   * This can be used to scale the image slice, which is the reason for some redundant arguments here.
   * Parameters: srcImage, srcImage_offsetX, srcImage_offsetY, srcImage_width, srcImage_height, dest_x, dest_y, dest_width, dest_height
   */
  context.drawImage(
    this.spritesheet,
    this.offsetX,
    this.offsetY,
    this.width,
    this.height,
    0,
    0,
    this.width,
    this.height
  );
  context.restore();
};

/* class variables
 */

Sprite.LEFT = 0;
Sprite.UP = 1;
Sprite.RIGHT = 2;
Sprite.DOWN = 3;

function Character(
  name,
  defnName,
  itemsEquipped,
  itemsInInventory,
  path,
  slice,
  frameWidth,
  frameHeight,
  pos,
  frameSpeed,
  startFrame,
  endFrame
) {
  this.name = name;
  this.defnName = defnName;
  this.itemsEquipped = itemsEquipped || [];
  this.itemsInInventory = itemsInInventory || [];
  this.speedX = 0;
  this.speedY = 0;
  this.sx = slice.x;
  this.sy = slice.y;
  this.x = pos.x;
  this.y = pos.y;
  // this.itemsEquippedByName =
  //     ArrayHelper.addLookupsByName(this.itemsEquipped);
  this.alive = false;
  this.action = null;
  this.effects = [];
  this.hasMovedThisTurn = false;
  this._visualArrow = menuArrow;

  this.gamearea = myGameArea;
  this.img = document.createElement("img");
  this.frameWidth = frameWidth;
  this.frameHeight = frameHeight;

  this.bulletPool = new Pool(30);
  this.bulletPool.init("bullet");
  this.speed = 3;
  var fireRate = 15;

  this.isColliding = false;
  this.dead = false;
  this.attacking = false;
  this.health = 100;
  this.healthMax = 100;
  this.energy = 10;
  this.energyMax = 10;

  var animationSequence = []; // array holding the order of the animation
  var currentFrame = 0; // the current frame to draw
  var counter = 0; // keep track of frame rate
  // start and end range for frames
  for (var frameNumber = startFrame; frameNumber <= endFrame; frameNumber++)
    animationSequence.push(frameNumber);

  var self = this;
  this.img.onload = function () {
    self.framesPerRow = Math.floor(self.img.width / self.frameWidth);
  };
  this.img.src = path;

  // To join a battle
  this.join = function (type) {
    this.type = type;
  };

  this.update = function () {
    if (this.dead) {
      return;
    }

    ctx = myGameArea.pCtx;

    ctx.drawImage(
      this.img,
      this.sx,
      this.sy,
      this.frameWidth,
      this.frameHeight,
      this.x,
      this.y,
      this.frameWidth,
      this.frameHeight
    );

    // SPACEBAR
    if (myGameArea.keys && myGameArea.keys[32]) {
      this.fire();
      counter = 0;
    }

    // if player is firing (and not reloading) then publish the PLAYER_FIRE event
    if (this.attacking) {
      console.log(this.attacking);
      // publish(EVENT.PLAYER_FIRE, this);
      // emitEvent('EVENT.PLAYER_FIRE', {
      // 	name: 'Merlin'
      // });
      // this.reloading = this.type.weapon.reload;
      // // Listen for the custom event
      // document.addEventListener('my-custom-event', function (event) {
      // 	console.log(event);
      // });
      //
      //
      // // Emit a custom event
      // emitEvent('my-custom-event');
      //
      // // Emit a custom event with details
      // emitEvent('my-custom-event', {
      // 	name: 'Merlin'
      // });
      //
      // // Emit a custom event on a specific element
      // let app = document.querySelector('#app');
      // emitEvent('my-custom-event', null, app);
      //
      // // Check if the event was canceled
      // let canceled = !emitEvent('my-custom-event');
    }
  };

  this.toMenu = function () {
    var textForAgent;
    if (this.name == null) {
      textForAgent = "Player";
    } else {
      textForAgent = this.name;
    }
    textForAgent += " (" + "H:" + this.health + "/" + this.healthMax;
    if (this.energyMax > 0) {
      textForAgent += " E:" + this.energy + "/" + this.energyMax;
    }
    textForAgent += ")";

    playerMenuArray.push(textForAgent);
  };

  this.newPos = function () {
    this.x += this.speedX;
    this.y += this.speedY;
  };

  this.animate = function () {
    // update to the next frame if it is time
    if (counter == frameSpeed - 1)
      currentFrame = (currentFrame + 1) % animationSequence.length;

    // update the counter
    counter = (counter + 1) % frameSpeed;

    ctx = myGameArea.pCtx;

    var row = Math.floor(animationSequence[currentFrame] / self.framesPerRow);
    var col = Math.floor(animationSequence[currentFrame] % self.framesPerRow);
    ctx.drawImage(
      this.img,
      col * this.frameWidth,
      row * this.frameHeight,
      this.frameWidth,
      this.frameHeight,
      this.x,
      this.y,
      this.frameWidth,
      this.frameHeight
    );

    this.speedX -= 1;

    this.hasTakenATurn = true;
  };

  this.fire = function () {
    this.bulletPool.getTwo(this.x + 6, this.y, 3, this.x + 33, this.y, 3);
  };

  this.crashWith = function (otherobj) {
    var myleft = this.x;
    var myright = this.x + this.frameWidth;
    var mytop = this.y;
    var mybottom = this.y + this.frameHeight;
    var otherleft = otherobj.x;
    var otherright = otherobj.x + otherobj.frameWidth;
    var othertop = otherobj.y;
    var otherbottom = otherobj.y + otherobj.frameHeight;
    var crash = true;
    if (
      mybottom < othertop ||
      mytop > otherbottom ||
      myright < otherleft ||
      myleft > otherright
    ) {
      crash = false;
    }
    return crash;
  };
}

function AnimateAcidSprite(
  name,
  path,
  slice,
  frameWidth,
  frameHeight,
  pos,
  frameSpeed,
  startFrame,
  endFrame
) {
  var animationSequence = []; // array holding the order of the animation
  var currentFrame = 0; // the current frame to draw
  var counter = 0; // keep track of frame rate
  // start and end range for frames
  for (var frameNumber = startFrame; frameNumber <= endFrame; frameNumber++)
    animationSequence.push(frameNumber);

  this.name = name;
  this.gamearea = myGameArea;
  this.img = document.createElement("img");
  this.frameWidth = frameWidth;
  this.frameHeight = frameHeight;
  this.hasTakenATurn = false;
  this.health = 100;
  this.healthMax = 100;
  this.energy = 10;
  this.energyMax = 10;

  this.isColliding = false;
  this.speedX = 0;
  this.speedY = 0;
  this.sx = slice.x;
  this.sy = slice.y;
  this.x = pos.x;
  this.y = pos.y;

  var self = this;
  this.img.onload = function () {
    self.framesPerRow = Math.floor(self.img.width / self.frameWidth);
  };
  this.img.src = path;

  this.update = function () {
    ctx = myGameArea.pCtx;

    // // update to the next frame if it is time
    // if (counter == (frameSpeed - 1))
    // 	currentFrame = (currentFrame + 1) % animationSequence.length;
    //
    // // update the counter
    // counter = (counter + 1) % frameSpeed;
    //
    // var row = Math.floor(animationSequence[currentFrame] / self.framesPerRow);
    // var col = Math.floor(animationSequence[currentFrame] % self.framesPerRow);
    ctx.drawImage(
      this.img,
      this.sx,
      this.sy,
      this.frameWidth,
      this.frameHeight,
      this.x,
      this.y,
      this.frameWidth,
      this.frameHeight
    );
  };

  this.newPos = function () {
    this.x += this.speedX;
    this.y += this.speedY;
  };

  this.toMenu = function () {
    var textForAgent;
    if (this.name == null) {
      textForAgent = "Enemy";
    } else {
      textForAgent = this.name;
    }
    textForAgent += " (" + "H:" + this.health + "/" + this.healthMax;
    if (this.energyMax > 0) {
      textForAgent += " E:" + this.energy + "/" + this.energyMax;
    }
    textForAgent += ")";

    enemyMenuArray.push(textForAgent);
  };

  this.animate = function () {
    // update to the next frame if it is time
    if (counter == frameSpeed - 1)
      currentFrame = (currentFrame + 1) % animationSequence.length;

    // update the counter
    counter = (counter + 1) % frameSpeed;

    ctx = myGameArea.pCtx;

    var row = Math.floor(animationSequence[currentFrame] / self.framesPerRow);
    var col = Math.floor(animationSequence[currentFrame] % self.framesPerRow);
    ctx.drawImage(
      this.img,
      col * this.frameWidth,
      row * this.frameHeight,
      this.frameWidth,
      this.frameHeight,
      this.x,
      this.y,
      this.frameWidth,
      this.frameHeight
    );

    this.speedX -= 1;

    this.hasTakenATurn = true;
  };
  this.crashWith = function (otherobj) {
    var myleft = this.x;
    var myright = this.x + this.frameWidth;
    var mytop = this.y;
    var mybottom = this.y + this.frameHeight;
    var otherleft = otherobj.x;
    var otherright = otherobj.x + otherobj.frameWidth;
    var othertop = otherobj.y;
    var otherbottom = otherobj.y + otherobj.frameHeight;
    var crash = true;
    if (
      mybottom < othertop ||
      mytop > otherbottom ||
      myright < otherleft ||
      myleft > otherright
    ) {
      crash = false;
    }
    return crash;
  };
}

function EnemySprite(name, path, slice, frameWidth, frameHeight, pos) {
  this.name = name;
  this.gamearea = myGameArea;
  this.img = document.createElement("img");
  this.frameWidth = frameWidth;
  this.frameHeight = frameHeight;
  this.action = null;
  this.effects = [];
  this.hasMovedThisTurn = false;
  this.dead = false;
  this.attacking = false;
  this.health = 100;
  this.healthMax = 100;
  this.energy = 10;
  this.energyMax = 10;

  this.isColliding = false;
  this.speedX = 0;
  this.speedY = 0;
  this.sx = slice.x;
  this.sy = slice.y;
  this.x = pos.x;
  this.y = pos.y;

  var percentFire = 0.01;
  var chance = 0;
  this.alive = false;

  this.img.src = path;

  this.update = function () {
    canvas = myGameArea.canvas;
    ctx = myGameArea.pCtx;

    ctx.drawImage(
      this.img,
      this.sx,
      this.sy,
      this.frameWidth,
      this.frameHeight,
      this.x,
      this.y,
      this.frameWidth,
      this.frameHeight
    );
  };

  this.toMenu = function () {
    var textForAgent;
    if (this.name == null) {
      textForAgent = "Enemy";
    } else {
      textForAgent = this.name;
    }
    textForAgent += " (" + "H:" + this.health + "/" + this.healthMax;
    if (this.energyMax > 0) {
      textForAgent += " E:" + this.energy + "/" + this.energyMax;
    }
    textForAgent += ")";

    enemyMenuArray.push(textForAgent);
  };

  this.newPos = function () {
    this.x += this.speedX;
    this.y += this.speedY;
  };
  this.crashWith = function (otherobj) {
    var myleft = this.x;
    var myright = this.x + this.frameWidth;
    var mytop = this.y;
    var mybottom = this.y + this.frameHeight;
    var otherleft = otherobj.x;
    var otherright = otherobj.x + otherobj.frameWidth;
    var othertop = otherobj.y;
    var otherbottom = otherobj.y + otherobj.frameHeight;
    var crash = true;
    if (
      mybottom < othertop ||
      mytop > otherbottom ||
      myright < otherleft ||
      myleft > otherright
    ) {
      crash = false;
    }
    return crash;
  };
}

function Light(x, y, z, brightness) {
  this.x = x === undefined ? -100 : x;
  this.y = y === undefined ? -100 : y;
  this.z = z === undefined ? -100 : z;
  this.brightness = brightness === undefined ? 1 : brightness;
}

Light.prototype.setBrightness = function (b) {
  this.brightness = Math.min(Math.max(b, 0), 1);
};

/**
 * Create a parallax background
 */
var background = (function () {
  this.gamearea = myGameArea;
  var sky = {};
  var backdrop = {};
  var backdrop2 = {};
  var bgImage = new Image();
  bgImage.src =
    "images/Battle-background-hazy-hills-files/PNG/battle-background-sunny-hillsX4.png";

  /**
   * Draw the backgrounds to the screen at different speeds
   */
  this.draw = function () {
    ctx = myGameArea.tCtx;
    ctx.drawImage(bgImage, 0, 0);
  };

  /**
   * Reset background to zero
   */
  this.reset = function () {
    sky.x = 0;
    sky.y = 0;
    sky.speed = 0.2;

    backdrop.x = 0;
    backdrop.y = 0;
    backdrop.speed = 0.4;

    backdrop2.x = 0;
    backdrop2.y = 0;
    backdrop2.speed = 0.6;
  };

  return {
    draw: this.draw,
    reset: this.reset,
  };
})();

function MenuText(text, pos, colorFill, width, height) {
  this.text = text;
  this.x = pos.x;
  this.y = pos.y;
  this.width = width;
  this.height = height;
  this.colorFill = colorFill;

  this.display = function () {
    canvas = myGameArea.hudCanvas;
    ctx = myGameArea.hCtx;
    ctx.save();

    var size = ctx.measureText(this.text);
    var x = this.x + (this.width - size.width) / 2;
    var y = this.y + (this.height - 15) / 2 + 12;

    ctx.fillStyle = "#FFF";
    ctx.font = "12px Arial";
    // ctx.fillText(this.text.heading, this.x, this.y + 5);
    //
    // const keys = Object.keys(this.text.items);

    // var self = this;
    // keys.forEach((key, index) => {
    //   ctx.fillText(self.text.items[key], this.x, this.y + 5 + (index + 1) * 20);
    // });
    // this.text.map((t, i) => )
    ctx.fillText(this.text, this.x, this.y + 5);
    // console.log(this.text)
  };
}

function Menu(
  text,
  pos,
  width,
  height,
  menuable,
  updateEncounter,
  children,
  indexOfChildSelected
) {
  this.text = text;
  this.width = width;
  this.height = height;
  this.x = pos.x;
  this.y = pos.y;
  this.menuable = menuable;
  this.updateEncounter = updateEncounter;
  this.children = children;
  this.indexOfChildSelected = indexOfChildSelected;
  // this._entityForArrow = { "pos": new Coords() };
  // this._visualArrow = new drawTriangle();

  // drawable
  this.draw = function () {
    canvas = myGameArea.hudCanvas;
    ctx = myGameArea.hCtx;

    ctx.rect(this.x, this.y, this.width, this.height);

    // create radial gradient
    var grd = ctx.createRadialGradient(this.x, this.y, 10, this.x, this.y, 300);
    // light blue
    //grd.addColorStop(0, '#8ED6FF');
    grd.addColorStop(0, "rgba(142, 214, 255, .3)");
    // dark blue
    // grd.addColorStop(1, '#004CB3');
    grd.addColorStop(1, "rgba(0, 76, 179, .3)");

    // save stae 1
    ctx.save();
    ctx.fillStyle = grd;

    ctx.strokeStyle = "white";

    ctx.strokeRect(this.x, this.y, this.width, this.height);
    ctx.fill();

    if (children != null) {
      ctx.fillStyle = "#FFF";
      ctx.font = "12px Arial";

      ctx.fillText("NAME", this.x + 15, this.y + 15);
      ctx.fillText("HP", this.x + 100, this.y + 15);
      ctx.fillText("MP", this.x + 200, this.y + 15);
      for (var i = 0; i < children.length; i++) {
        var child = children[i];

        ctx.fillText(child, this.x + 15, this.y + (i + 2) * 15);

        // display.drawText(displayText, display.fontHeightInPixels, drawPos);
        // if (i == menu.indexOfChildSelected) {
        //     this._entityForArrow.pos.overwriteWith(drawPos); // hack
        //     this._visualArrow.draw(universe, world, display, this._entityForArrow);
        // }
        // drawPos.add(spacing);
      } // end for
    }
  };
}

// Page 159; /examples_explore/gui-1-solution/Panel.lua
function Panel(params) {
  this.texture = params.texture;
  // this.UVs = null;
  this.UVs = GenerateUVs(params.size, params.size, params.texture);
  this.tileSize = params.size;
  this.tiles = []; // the sprites representing the border.
}

Panel.prototype.create = function () {
  // -- Fix up center U,Vs by moving them 0.5 texels in.
  var center = this.UVs[5];
  var pixelToTexelX = 1 / this.texture.width;
  var pixelToTexelY = 1 / this.texture.height;

  center[1] = center[1] + pixelToTexelX / 2;
  center[2] = center[2] + pixelToTexelY / 2;
  center[3] = center[3] - pixelToTexelX / 2;
  center[4] = center[4] - pixelToTexelY / 2;
  // -- The center sprite is going to be 1 pixel smaller on the X, Y
  // -- So we need a variable that will account for that when scaling.
  this.centerScale = this.tileSize / (this.tileSize - 1);

  // -- Create a sprite for each tile of the panel
  // -- 1. top left      2. top          3. top right
  // -- 4. left          5. middle       6. right
  // -- 7. bottom left   8. bottom       9. bottom right
  // for (var column = 0; column < this.UVs.length; column++) {
  //   for (var row = 0; row < this.UVs.length; row++) {
  //     var tile = this.texture;
  //     var x = column * this.tileSize;
  //     var y = row * this.tileSize;
  //     drawTile(tile, x, y);
  // 		this.tiles.push({tile, x, y});
  //   }
  // }

  var self = this;
  for (var i = 0; i < this.UVs.length; i++) {
    var sprite = this.texture;
    var uv = this.UVs[i];
    var uvVal = Object.values(uv);
    if (isNaN(uvVal)) {
      // console.log('uvVal: ', uvVal[i]);
    }
    this.tiles.push({ sprite, uv });
    // ctx = myGameArea.context;
    // ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
    // var sprite = Sprite.create();
    // sprite.setTexture(this.texture);
    // sprite.setUVs(this.UVs[i]);
    // this.tiles[i] = sprite;
  }

  return this;
};

Panel.prototype.position = function (left, top, right, bottom) {
  // -- Reset scales
  for (var i = 0; i < this.tiles.length; i++) {
    this.tiles[i].setScale(1, 1);
  }

  var hSize = this.tileSize / 2;
  // -- Align the corner tiles
  this.tiles[1].setPosition(left + hSize, top - hSize);
  this.tiles[3].setPosition(right - hSize, top - hSize);
  this.tiles[7].setPosition(left + hSize, bottom + hSize);
  this.tiles[9].setPosition(right - hSize, bottom + hSize);

  // -- Calculate how much to scale the side tiles
  var widthScale = (Math.abs(right - left) - 2 * this.tileSize) / this.tileSize;
  var centerX = (right + left) / 2;

  this.tiles[2].setPosition(centerX, top - hSize);
  this.tiles[2].setScale(widthScale, 1);

  this.tiles[8].setPosition(centerX, bottom + hSize);
  this.tiles[8].setScale(widthScale, 1);

  var heightScale =
    (Math.abs(bottom - top) - 2 * this.tileSize) / this.tileSize;
  var centerY = (top + bottom) / 2;

  this.tiles[4].setScale(1, heightScale);
  this.tiles[4].setPosition(left + hSize, centerY);

  this.tiles[6].setScale(1, heightScale);
  this.tiles[6].setPosition(right - hSize, centerY);

  // -- Scale the middle backing panel
  this.tiles[5].setScale(
    widthScale * this.centerScale,
    heightScale * this.centerScale
  );
  this.tiles[5].setPosition(centerX, centerY);

  // -- Hide corner tiles when scale is equal to zero
  if (left - right == 0 || top - bottom == 0) {
    for (var i = 0; i < this.tiles.length; i++) {
      this.tiles[i].setScale(0, 0);
    }
  }
};

Panel.prototype.centerPosition = function (x, y, width, height) {
  var hWidth = width / 2;
  var hHeight = height / 2;
  return this.position(x - hWidth, y + hHeight, x + hWidth, y - hHeight);
};

Panel.prototype.render = function () {
  this.gamearea = myGameArea;

  ctx = this.gamearea.hCtx;

  // Top Left
  ctx.drawImage(
    this.texture, // image
    1, // source x
    1, // source y
    3, // source width
    3, // source height
    this.tiles[0].sprite.width + 335, // target x
    this.tiles[0].sprite.width + 515, // target y
    this.tiles[0].sprite.width, // target width
    this.tiles[0].sprite.height // target height
  );

  // Top Right
  ctx.drawImage(
    this.texture, // image
    4, // source x
    1, // source y
    3, // source width
    3, // source height
    this.tiles[0].sprite.width + 1002, // target x
    this.tiles[0].sprite.width + 515, // target y
    this.tiles[0].sprite.width, // target width
    this.tiles[0].sprite.height // target height
  );

  var panelCols = 82;
  var panelRows = 12;
  for (var c = 0; c < panelCols; c++) {
    for (var r = 0; r < panelRows; r++) {
      // Top
      ctx.drawImage(
        this.texture, // image
        3, // source x
        1, // source y
        3, // source width
        3, // source height
        this.tiles[0].sprite.width + 345 + c * 8, // target x
        this.tiles[0].sprite.width + 515, // target y
        this.tiles[0].sprite.width, // target width
        this.tiles[0].sprite.height // target height
      );

      // Left
      ctx.drawImage(
        this.texture, // image
        1, // source x
        3, // source y
        3, // source width
        3, // source height
        this.tiles[0].sprite.width + 335, // target x
        this.tiles[0].sprite.width + 524 + r * 8, // target y
        this.tiles[0].sprite.width, // target width
        this.tiles[0].sprite.height // target height
      );

      // Center
      ctx.drawImage(
        this.texture, // image
        3, // source x
        3, // source y
        3, // source width
        3, // source height
        this.tiles[5].sprite.width + 345 + c * 8, // target x
        this.tiles[5].sprite.width + 524 + r * 8, // target y
        this.tiles[5].sprite.width, // target width
        this.tiles[5].sprite.height // target height
      );

      // Right
      ctx.drawImage(
        this.texture, // image
        4, // source x
        3, // source y
        3, // source width
        3, // source height
        this.tiles[0].sprite.width + 1003, // target x
        this.tiles[0].sprite.width + 524 + r * 8, // target y
        this.tiles[0].sprite.width, // target width
        this.tiles[0].sprite.height // target height
      );

      // Bottom
      ctx.drawImage(
        this.texture, // image
        3, // source x
        4, // source y
        3, // source width
        3, // source height
        this.tiles[5].sprite.width + 345 + c * 8, // target x
        this.tiles[5].sprite.width + 620, // target y
        this.tiles[5].sprite.width, // target width
        this.tiles[5].sprite.height // target height
      );
    }
  }
  // Bottom Left
  ctx.drawImage(
    this.texture, // image
    1, // source x
    4, // source y
    3, // source width
    3, // source height
    this.tiles[0].sprite.width + 335, // target x
    this.tiles[0].sprite.width + 620, // target y
    this.tiles[0].sprite.width, // target width
    this.tiles[0].sprite.height // target height
  );

  // Bottom Right
  ctx.drawImage(
    this.texture, // image
    4, // source x
    4, // source y
    3, // source width
    3, // source height
    this.tiles[0].sprite.width + 1003, // target x
    this.tiles[0].sprite.width + 620, // target y
    this.tiles[0].sprite.width, // target width
    this.tiles[0].sprite.height // target height
  );

  // for (var i = 0; i < this.tiles.length; i++) {
  // 	ctx = this.gamearea.context;
  // 	ctx.drawImage(this.tiles[i].sprite, this.tiles[i].uv.ux, this.tiles[i].uv.uy, this.tiles[i].sprite.width, this.tiles[i].sprite.height, this.tiles[i].uv.vx, this.tiles[i].uv.vy, this.tiles[i].sprite.width, this.tiles[i].sprite.height);
  // 	// ctx.drawImage(imageRepository.panelTexture, 0, 0);
  // 	// renderer.drawSprite(this.tiles[i]);
  // }
};

function Textbox(params) {
  this.text = params.text;
  this.textScale = params.textScale || 1;
  this.panel = new Panel(params.panelArgs).create();
  this.size = params.size;
  this.bounds = params.textbounds;
}

Textbox.prototype.create = function () {
  // -- Calculate center point from mSize
  // -- We can use this to scale.
  this.x = (this.size.right + this.size.left) / 2;
  this.y = (this.size.top + this.size.bottom) / 2;
  this.width = this.size.right - this.size.left;
  this.height = this.size.top - this.size.bottom;

  return this;
};

Textbox.prototype.render = function (context) {
  var scale = 1;

  context.scale(this.textScale * scale);
  context.textAlign = "left";
  // -- Draw the scale panel
  this.panel.centerPosition(
    this.x,
    this.y,
    this.width * scale,
    this.height * scale
  );

  this.panel.render(context);

  var left = this.x - (this.width / 2) * scale;
  var textLeft = left + this.bounds.left * scale;
  var top = this.y + (this.height / 2) * scale;
  var textTop = top + this.bounds.top * scale;

  context.fillStyle = "#FFFFFF";
  context.fillText(this.text, textLeft, textTop);
};

function Progress() {
  this.gamearea = myGameArea;
  this.widths = 0;
  this.hue = 0;

  this.x = 23 + this.widths;
  this.y = 82;

  this.vx = 0.8 + Math.random() * 1;
  this.v = Math.random() * 5;
  this.g = 1 + Math.random() * 3;
  this.down = false;

  var particle_no = 25;
  var particles = [];
  var w = 400;
  var h = 200;

  var animationSequence = []; // array holding the order of the animation
  var currentFrame = 0; // the current frame to draw
  var counter = 0; // keep track of frame rate
  // start and end range for frames

  var self = this;

  this.reset = function () {
    ctx.fillStyle = "#171814";
    ctx.fillRect(25, 80, 350, 25);
  };

  this.update = function () {
    for (var i = 0; i < particles.length; i++) {
      var p = particles[i];
      p.x -= p.vx;
      if (p.down == true) {
        p.g += 0.1;
        p.y += p.g;
      } else {
        if (p.g < 0) {
          p.down = true;
          p.g += 0.1;
          p.y += p.g;
        } else {
          p.y -= p.g;
          p.g -= 0.1;
        }
      }
      p.draw();
    }
  };

  this.animate = function () {
    this.reset();
    counter++;

    this.hue += 0.8;

    this.widths += 2;
    if (this.widths > 350) {
      if (counter > 215) {
        this.reset();
        this.hue = 0;
        this.widths = 0;
        counter = 0;
        particles = [];
      } else {
        this.hue = 126;
        this.widths = 351;
        this.drawProgressBar();
      }
    } else {
      this.drawProgressBar();
      for (var i = 0; i < particle_no; i += 10) {
        particles.push(new particle());
      }
    }
    this.update();
  };

  this.display = function () {
    var canvas = gamearea.hudCanvas;
    var ctx = gamearea.hCtx;

    // Draw background
    ctx.fillStyle = "hsla(" + this.hue + ", 100%, 50%, 1)";
    ctx.fillRect(25, 80, this.widths, 25);
    var grad = ctx.createLinearGradient(0, 0, 0, 180);
    grad.addColorStop(0, "transparent");
    grad.addColorStop(1, "rgba(0,0,0,0.8)");
    ctx.fillStyle = grad;
    ctx.fillRect(25, 80, this.widths, 25);
  };

  this.drawProgressBar = function () {
    var canvas = gamearea.hudCanvas;
    var ctx = gamearea.hCtx;

    // Draw background
    ctx.fillStyle = "hsla(" + this.hue + ", 100%, 50%, 1)";
    ctx.fillRect(25, 80, this.widths, 25);
    var grad = ctx.createLinearGradient(0, 0, 0, 180);
    grad.addColorStop(0, "transparent");
    grad.addColorStop(1, "rgba(0,0,0,0.8)");
    ctx.fillStyle = grad;
    ctx.fillRect(25, 80, this.widths, 25);
  };

  this.drawParticle = function () {
    ctx.fillStyle = "hsla(" + (bar.hue + 0.3) + ", 100%, 40%, 1)";
    var size = Math.random() * 2;
    ctx.fillRect(this.x, this.y, size, size);
  };
}

function particle() {
  this.x = 23 + bar.widths;
  this.y = 82;

  this.vx = 0.8 + Math.random() * 1;
  this.v = Math.random() * 5;
  this.g = 1 + Math.random() * 3;
  this.down = false;

  this.draw = function () {
    ctx.fillStyle = "hsla(" + (bar.hue + 0.3) + ", 100%, 40%, 1)";
    var size = Math.random() * 2;
    ctx.fillRect(this.x, this.y, size, size);
  };
}

function ProgressBar() {
  this.gamearea = myGameArea;
  // this.x = pos.x;
  // this.y = pos.y;

  this.display = function () {
    var canvas = gamearea.hudCanvas;
    var ctx = gamearea.hCtx;

    // Draw background
    ctx.fillStyle = "rgb(255, 221, 0)";
    ctx.fillRect(850, 535, 75, 20);
    ctx.fillStyle = "rgb(102, 204, 0)";
    ctx.fillRect(850, 560, 75, 20);
    ctx.fillStyle = "rgb(0, 153, 255)";
    ctx.fillRect(850, 585, 75, 20);
    ctx.fillStyle = "rgb(255, 51, 0)";
    ctx.fillRect(850, 610, 75, 20);

    // Draw semi transparent rectangles
    for (var i = 0; i < 10; i++) {
      ctx.fillStyle = `rgba(255, 255, 255, ${(i + 1) / 10})`;
      for (var j = 0; j < 4; j++) {
        ctx.fillRect(854 + i * 7, 537 + j * 25, 7, 16);
      }
    }
  };
}

function drawTriangle() {
  this.update = function () {
    ctx = myGameArea.hCtx;

    ctx.beginPath();
    ctx.moveTo(75, 50);
    ctx.lineTo(100, 75);
    ctx.lineTo(100, 25);
    ctx.fill();
  };
}

function Comet() {
  ctx = myGameArea.eCtx;
  var canvas = myGameArea.environmentCanvas;

  var xPos = -100;
  var yPos = 170;
  var motionTrailLength = 10;
  var positions = [];

  this.drawCircle = function (x, y, r) {
    if (r == "source") {
      r = 1;
    } else {
      r /= 4;
    }

    ctx.beginPath();
    ctx.arc(x, y, 50, 0, 2 * Math.PI, true);
    ctx.fillStyle = "rgba(204, 102, 153, " + r + ")";
    ctx.fill();
  };

  this.storeLastPosition = function (xPos, yPos) {
    // push an item
    positions.push({
      x: xPos,
      y: yPos,
    });

    //get rid of first item
    if (positions.length > motionTrailLength) {
      positions.shift();
    }
  };

  this.update = function () {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    for (var i = 0; i < positions.length; i++) {
      var ratio = (i + 1) / positions.length;
      this.drawCircle(positions[i].x, positions[i].y, ratio);
    }

    this.drawCircle(xPos, yPos, "source");

    this.storeLastPosition(xPos, yPos);

    // update position
    if (xPos > 600) {
      xPos = -100;
    }
    xPos += 3;
  };
}

function MagicExplosion(
  path,
  slice,
  frameWidth,
  frameHeight,
  pos,
  frameSpeed,
  startFrame,
  endFrame
) {
  var animationSequence = []; // array holding the order of the animation
  var currentFrame = 0; // the current frame to draw
  var counter = 0; // keep track of frame rate
  // start and end range for frames
  for (var frameNumber = startFrame; frameNumber <= endFrame; frameNumber++)
    animationSequence.push(frameNumber);

  this.gamearea = myGameArea;
  this.img = document.createElement("img");
  this.frameWidth = frameWidth;
  this.frameHeight = frameHeight;
  this.hasTakenATurn = false;
  this.isColliding = false;

  this.speedX = 0;
  this.speedY = 0;
  this.sx = slice.x;
  this.sy = slice.y;
  this.x = pos.x;
  this.y = pos.y;

  var self = this;
  this.img.onload = function () {
    self.framesPerRow = Math.floor(self.img.width / self.frameWidth);
  };
  this.img.src = path;

  this.update = function () {
    ctx = myGameArea.eCtx;

    ctx.drawImage(
      this.img,
      this.sx,
      this.sy,
      this.frameWidth,
      this.frameHeight,
      this.x,
      this.y,
      this.frameWidth,
      this.frameHeight
    );
  };

  this.newPos = function () {
    this.x += this.speedX;
    this.y += this.speedY;
  };

  this.animate = function () {
    // update to the next frame if it is time
    if (counter == frameSpeed - 1)
      currentFrame = (currentFrame + 1) % animationSequence.length;

    // update the counter
    counter = (counter + 1) % frameSpeed;

    ctx = myGameArea.eCtx;

    var row = Math.floor(animationSequence[currentFrame] / self.framesPerRow);
    var col = Math.floor(animationSequence[currentFrame] % self.framesPerRow);
    ctx.drawImage(
      this.img,
      col * this.frameWidth,
      row * this.frameHeight,
      this.frameWidth,
      this.frameHeight,
      this.x,
      this.y,
      this.frameWidth,
      this.frameHeight
    );

    this.speedX -= 1;

    this.hasTakenATurn = true;
  };

  this.crashWith = function (otherobj) {
    var myleft = this.x;
    var myright = this.x + this.frameWidth;
    var mytop = this.y;
    var mybottom = this.y + this.frameHeight;
    var otherleft = otherobj.x;
    var otherright = otherobj.x + otherobj.frameWidth;
    var othertop = otherobj.y;
    var otherbottom = otherobj.y + otherobj.frameHeight;
    var crash = true;
    if (
      mybottom < othertop ||
      mytop > otherbottom ||
      myright < otherleft ||
      myleft > otherright
    ) {
      crash = false;
    }
    return crash;
  };
}

function updateGameArea() {
  var x;
  var y;
  // for (i = 0; i < enemies.length; i += 1) {
  //   if (hero.crashWith(enemies[i])) {
  //     myGameArea.stop();
  //     return;
  //   }
  // }
  // if (character.crashWith(goblin)) {
  // 	myGameArea.stop();
  // }
  myGameArea.clear();
  myGameArea.frameNo += 1;
  // light.start();
  // if (myGameArea.frameNo == 1 || everyinterval(150)) {
  //   x = myGameArea.canvas.width;
  //   y = myGameArea.canvas.height - 200
  //   enemies.push(new component(10, 200, "green", x, y));
  // }
  // for (i = 0; i < enemies.length; i += 1) {
  //   enemies[i].x += -1;
  //   enemies[i].update();
  // }
  spritesheet = new Image();
  spritesheet.src = "images/combat_hero.png";
  sprite = new Sprite(spritesheet, 5, 13); // params: image, columns, rows
  right_boundary = myGameArea.pCtx.width;
  left_boundary = 0;
  vx = 0;

  // initial character position
  sprite.x = 400;
  sprite.y = 260;
  character.speedX = 0;
  character.speedY = 0;
  mageBullet.speedX = 0;
  mageBullet.speedY = 0;
  if (myGameArea.keys && myGameArea.keys[37]) {
    character.speedX = -1;
    sprite.play(Sprite.LEFT);
    vx = -2;
  }
  if (myGameArea.keys && myGameArea.keys[39]) {
    character.speedX = 1;
    sprite.play(Sprite.RIGHT);
    vx = 2;
  }
  if (myGameArea.keys && myGameArea.keys[38]) {
    character.speedY = -1;
    sprite.play(Sprite.UP);
  }
  if (myGameArea.keys && myGameArea.keys[40]) {
    character.speedY = 1;
    sprite.play(Sprite.DOWN);
  }

  sprite.stop();
  vx = 0;

  // background.draw();

  // HERO's PARTY
  // if (myGameArea.frameNo < 50) {
  //   character.animate();
  //   mageBullet.animate();
  // }
  character.update();
  character.newPos();

  ninja.update();
  // thief.update();
  thief.draw(myGameArea.pCtx);
  // rogue.update();
  // paladin.update();
  knight.update();
  healer.update();
  mage.update();
  warrior.update();

  playerMenu.draw();
  partyActionsMenu.draw();
  // textbox.render(myGameArea.hCtx);

  // progress.display();
  // mageBullet.update();
  // character.bulletPool.animate();
  // comet.update();
  // bar.animate();
  // gPanel.render();

  acid.x += vx;
  darkMage.x += vx;
  shadow.x += vx;
  tentacles.x += vx;
  andromalius.x += vx;
  gnu.x += vx;
  disciple.x += vx;
  sprite.x += vx;
  // screen wrapping
  if (sprite.x > right_boundary) {
    sprite.x = left_boundary - sprite.width;
  } else if (sprite.x + sprite.width < left_boundary) {
    sprite.x = right_boundary;
  }

  if (disciple.x > right_boundary) {
    disciple.x = left_boundary - disciple.width;
  } else if (disciple.x + disciple.width < left_boundary) {
    disciple.x = right_boundary;
  }

  if (acid.x > right_boundary) {
    acid.x = left_boundary - acid.width;
  } else if (acid.x + acid.width < left_boundary) {
    acid.x = right_boundary;
  }

  if (darkMage.x > right_boundary) {
    darkMage.x = left_boundary - darkMage.width;
  } else if (darkMage.x + darkMage.width < left_boundary) {
    darkMage.x = right_boundary;
  }

  if (shadow.x > right_boundary) {
    shadow.x = left_boundary - shadow.width;
  } else if (shadow.x + shadow.width < left_boundary) {
    shadow.x = right_boundary;
  }

  if (tentacles.x > right_boundary) {
    tentacles.x = left_boundary - tentacles.width;
  } else if (tentacles.x + tentacles.width < left_boundary) {
    tentacles.x = right_boundary;
  }

  if (andromalius.x > right_boundary) {
    andromalius.x = left_boundary - andromalius.width;
  } else if (andromalius.x + andromalius.width < left_boundary) {
    andromalius.x = right_boundary;
  }

  if (gnu.x > right_boundary) {
    gnu.x = left_boundary - gnu.width;
  } else if (gnu.x + gnu.width < left_boundary) {
    gnu.x = right_boundary;
  }

  sprite.draw(myGameArea.pCtx);

  // ENEMIES
  acid.draw(myGameArea.pCtx);
  darkMage.draw(myGameArea.pCtx);
  shadow.draw(myGameArea.pCtx);
  tentacles.draw(myGameArea.pCtx);
  andromalius.draw(myGameArea.pCtx);
  gnu.draw(myGameArea.pCtx);
  disciple.draw(myGameArea.pCtx);

  acid.tick();
  darkMage.tick();
  shadow.tick();
  tentacles.tick();
  andromalius.tick();
  gnu.tick();
  disciple.tick();

	gMap.render();


  // var canvas = document.getElementById('KochDemo'),
  // fract = new Fractal.Koch(canvas, {x: 0, y: 0}, 5, "#477ff1");
  //
  // var start = {x: canvas.width / 2, y: canvas.height},
  // target = {x: 0, y: 0},
  // kochAnim = new Fractal.Animation(fract, start, target);
  //
  // kochAnim.skip(4000);
  //
  // canvas = document.getElementById('PythagorasDemo'),
  // fract = new Fractal.Pythagoras(canvas, {x: 0, y: 0}, 9, "#D4E576","#126845");
  //
  // start = {x: canvas.width / 2, y: canvas.height};
  // target = {x: 0, y: 0};
  // var pythAnim = new Fractal.Animation(fract, start, target);
  //
  // pythAnim.skip(6000);
  //
  // canvas = document.getElementById('HTreeDemo'),
  // fract = new Fractal.HTree(canvas, {x: 0, y: 0}, 14, "black", "rgba(91,0,144,0.3)", true);
  //
  // start = {x: canvas.width / 2, y: canvas.height};
  // target = {x: canvas.width / 4, y: canvas.height / 7};
  // var htreeAnim = new Fractal.Animation(fract, start, target);
  //
  // htreeAnim.skip(2000);

  // var trees = [],
  // 		numTrees = 100,
  // 		fl = 250,
  // 		vpX = canvas.width / 2,
  // 		vpY = canvas.height / 2,
  // 		floor = 50,
  // 		ax = 0,
  // 		ay = 0,
  // 		az = 0,
  // 		vx = 0,
  // 		vy = 0,
  // 		vz = 0,
  // 		gravity = 0.3,
  // 		friction = 0.95;
  //
  // 		for (var tree, i = 0; i < numTrees; i++) {
  // 			tree = new Tree();
  // 			tree.xpos = Math.random() * 2000 - 1000;
  // 			tree.ypos = floor;
  // 			tree.zpos = Math.random() * 10000;
  // 			trees.push(tree);
  // 		}
  //
  // 		function move (tree) {
  // 			tree.xpos += vx;
  // 			tree.ypos += vy;
  // 			tree.zpos += vz;
  //
  // 			if (tree.ypos < floor) {
  // 				tree.ypos = floor;
  // 			}
  // 			if (tree.zpos < -fl) {
  // 				tree.zpos += 10000;
  // 			}
  // 			if (tree.zpos > 10000 - fl) {
  // 				tree.zpos -= 10000;
  // 			}
  // 			var scale = fl / (fl + tree.zpos);
  // 			tree.scaleX = tree.scaleY = scale;
  // 			tree.x = vpX + tree.xpos * scale;
  // 			tree.y = vpY + tree.ypos * scale;
  // 			tree.alpha = scale;
  // 		}
  //
  // 		function zSort (a, b) {
  // 			return (b.zpos - a.zpos);
  // 		}
  //
  // 		function draw (tree) {
  // 			tree.draw(ctx);
  // 		}
  //
  //
  // 			ctx.clearRect(0, 0, myGameArea.canvas.width, myGameArea.canvas.height);
  //
  // 			vx += ax;
  // 			vy += ay;
  // 			vz += az;
  // 			vy -= gravity;
  // 			trees.forEach(move);
  // 			vx *= friction;
  // 			vy *= friction;
  // 			vz *= friction;
  // 			trees.sort(zSort);
  // 			trees.forEach(draw);
}

startGame();
